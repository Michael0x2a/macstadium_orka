// Package orka provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.9.0 DO NOT EDIT.
package orka

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
)

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetDefaultBaseImage request
	GetDefaultBaseImage(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CheckApiVersion request
	CheckApiVersion(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteLogs request
	DeleteLogs(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListLogs request
	ListLogs(ctx context.Context, params *ListLogsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CommitChangesToTheBaseImage request with any body
	CommitChangesToTheBaseImageWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CommitChangesToTheBaseImage(ctx context.Context, body CommitChangesToTheBaseImageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CopyImage request with any body
	CopyImageWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CopyImage(ctx context.Context, body CopyImageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteImage request with any body
	DeleteImageWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteImage(ctx context.Context, body DeleteImageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GenerateEmptyStorage request with any body
	GenerateEmptyStorageWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GenerateEmptyStorage(ctx context.Context, body GenerateEmptyStorageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListImages request
	ListImages(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListRemoteImages request
	ListRemoteImages(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PullImage request with any body
	PullImageWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PullImage(ctx context.Context, body PullImageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RenameImage request with any body
	RenameImageWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RenameImage(ctx context.Context, body RenameImageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ResizeImage request with any body
	ResizeImageWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ResizeImage(ctx context.Context, body ResizeImageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SaveNewBaseImageFromVm request with any body
	SaveNewBaseImageFromVmWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SaveNewBaseImageFromVm(ctx context.Context, body SaveNewBaseImageFromVmJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UploadAnImage request with any body
	UploadAnImageWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CopyIso request with any body
	CopyIsoWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CopyIso(ctx context.Context, body CopyIsoJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteIso request with any body
	DeleteIsoWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteIso(ctx context.Context, body DeleteIsoJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListIsOsInLocalStorage request
	ListIsOsInLocalStorage(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListRemoteIsOs request
	ListRemoteIsOs(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PullIso request with any body
	PullIsoWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PullIso(ctx context.Context, body PullIsoJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RenameIso request with any body
	RenameIsoWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RenameIso(ctx context.Context, body RenameIsoJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UploadAnIso request with any body
	UploadAnIsoWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteKubeAccount request with any body
	DeleteKubeAccountWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteKubeAccount(ctx context.Context, body DeleteKubeAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListKubeAccounts request with any body
	ListKubeAccountsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ListKubeAccounts(ctx context.Context, body ListKubeAccountsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateKubeAccount request with any body
	CreateKubeAccountWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateKubeAccount(ctx context.Context, body CreateKubeAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DownloadKubeconfig request with any body
	DownloadKubeconfigWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DownloadKubeconfig(ctx context.Context, body DownloadKubeconfigJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RegenerateKubeAccount request with any body
	RegenerateKubeAccountWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RegenerateKubeAccount(ctx context.Context, body RegenerateKubeAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveNodeDedication request with any body
	RemoveNodeDedicationWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RemoveNodeDedication(ctx context.Context, body RemoveNodeDedicationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DedicateNode request with any body
	DedicateNodeWithBody(ctx context.Context, userGroup string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DedicateNode(ctx context.Context, userGroup string, body DedicateNodeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListAllNodesAdmin request
	ListAllNodesAdmin(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DisableSandbox request with any body
	DisableSandboxWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DisableSandbox(ctx context.Context, body DisableSandboxJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EnableSandbox request with any body
	EnableSandboxWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	EnableSandbox(ctx context.Context, body EnableSandboxJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CheckNodeStatus request
	CheckNodeStatus(ctx context.Context, node string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListPorts request
	ListPorts(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AttachDisk request with any body
	AttachDiskWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AttachDisk(ctx context.Context, body AttachDiskJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CloneVm request with any body
	CloneVmWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CloneVm(ctx context.Context, body CloneVmJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListYourVmConfigurations request with any body
	ListYourVmConfigurationsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SaveVmState request with any body
	SaveVmStateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SaveVmState(ctx context.Context, body SaveVmStateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetVmConfigurationByName request with any body
	GetVmConfigurationByNameWithBody(ctx context.Context, vm string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteVmState request with any body
	DeleteVmStateWithBody(ctx context.Context, vm string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateVmConfiguration request with any body
	CreateVmConfigurationWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateVmConfiguration(ctx context.Context, body CreateVmConfigurationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteUserSVmAdmin request with any body
	DeleteUserSVmAdminWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteUserSVmAdmin(ctx context.Context, body DeleteUserSVmAdminJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeployVmConfiguration request with any body
	DeployVmConfigurationWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeployVmConfiguration(ctx context.Context, body DeployVmConfigurationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ResumeVm request with any body
	ResumeVmWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ResumeVm(ctx context.Context, body ResumeVmJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RevertVm request with any body
	RevertVmWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RevertVm(ctx context.Context, body RevertVmJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StartVm request with any body
	StartVmWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	StartVm(ctx context.Context, body StartVmJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StopVm request with any body
	StopVmWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	StopVm(ctx context.Context, body StopVmJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SuspendVm request with any body
	SuspendVmWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SuspendVm(ctx context.Context, body SuspendVmJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListYourVMs request
	ListYourVMs(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListDisks request with any body
	ListDisksWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ListDisks(ctx context.Context, body ListDisksJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListAllVMsAdmin request
	ListAllVMsAdmin(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListUserSVMsAdmin request
	ListUserSVMsAdmin(ctx context.Context, email string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MigrateVm request with any body
	MigrateVmWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	MigrateVm(ctx context.Context, body MigrateVmJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PurgeUserSVMsAdmin request with any body
	PurgeUserSVMsAdminWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PurgeUserSVMsAdmin(ctx context.Context, body PurgeUserSVMsAdminJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UnScaleVm request with any body
	UnScaleVmWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UnScaleVm(ctx context.Context, body UnScaleVmJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CheckUserSVmStatusAdmin request
	CheckUserSVmStatusAdmin(ctx context.Context, vm string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RevokeToken request
	RevokeToken(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CheckTokenStatus request
	CheckTokenStatus(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateToken request with any body
	CreateTokenWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateToken(ctx context.Context, body CreateTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUsers request
	GetUsers(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateUser request with any body
	CreateUserWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateUser(ctx context.Context, body CreateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateUser request with any body
	UpdateUserWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateUser(ctx context.Context, body UpdateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UngroupUsers request with any body
	UngroupUsersWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UngroupUsers(ctx context.Context, body UngroupUsersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GroupUsers request with any body
	GroupUsersWithBody(ctx context.Context, userGroup string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GroupUsers(ctx context.Context, userGroup string, body GroupUsersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ResetPasswordAdmin request with any body
	ResetPasswordAdminWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ResetPasswordAdmin(ctx context.Context, body ResetPasswordAdminJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteUser request
	DeleteUser(ctx context.Context, email string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ValidateLicenseKey request with any body
	ValidateLicenseKeyWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ValidateLicenseKey(ctx context.Context, body ValidateLicenseKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CheckPasswordRequirements request
	CheckPasswordRequirements(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetDefaultBaseImage(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDefaultBaseImageRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CheckApiVersion(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCheckApiVersionRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteLogs(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteLogsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListLogs(ctx context.Context, params *ListLogsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListLogsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CommitChangesToTheBaseImageWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCommitChangesToTheBaseImageRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CommitChangesToTheBaseImage(ctx context.Context, body CommitChangesToTheBaseImageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCommitChangesToTheBaseImageRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CopyImageWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCopyImageRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CopyImage(ctx context.Context, body CopyImageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCopyImageRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteImageWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteImageRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteImage(ctx context.Context, body DeleteImageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteImageRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GenerateEmptyStorageWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGenerateEmptyStorageRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GenerateEmptyStorage(ctx context.Context, body GenerateEmptyStorageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGenerateEmptyStorageRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListImages(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListImagesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListRemoteImages(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListRemoteImagesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PullImageWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPullImageRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PullImage(ctx context.Context, body PullImageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPullImageRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RenameImageWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRenameImageRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RenameImage(ctx context.Context, body RenameImageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRenameImageRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ResizeImageWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewResizeImageRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ResizeImage(ctx context.Context, body ResizeImageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewResizeImageRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SaveNewBaseImageFromVmWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSaveNewBaseImageFromVmRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SaveNewBaseImageFromVm(ctx context.Context, body SaveNewBaseImageFromVmJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSaveNewBaseImageFromVmRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UploadAnImageWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUploadAnImageRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CopyIsoWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCopyIsoRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CopyIso(ctx context.Context, body CopyIsoJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCopyIsoRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteIsoWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteIsoRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteIso(ctx context.Context, body DeleteIsoJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteIsoRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListIsOsInLocalStorage(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListIsOsInLocalStorageRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListRemoteIsOs(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListRemoteIsOsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PullIsoWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPullIsoRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PullIso(ctx context.Context, body PullIsoJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPullIsoRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RenameIsoWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRenameIsoRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RenameIso(ctx context.Context, body RenameIsoJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRenameIsoRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UploadAnIsoWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUploadAnIsoRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteKubeAccountWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteKubeAccountRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteKubeAccount(ctx context.Context, body DeleteKubeAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteKubeAccountRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListKubeAccountsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListKubeAccountsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListKubeAccounts(ctx context.Context, body ListKubeAccountsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListKubeAccountsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateKubeAccountWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateKubeAccountRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateKubeAccount(ctx context.Context, body CreateKubeAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateKubeAccountRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DownloadKubeconfigWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDownloadKubeconfigRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DownloadKubeconfig(ctx context.Context, body DownloadKubeconfigJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDownloadKubeconfigRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RegenerateKubeAccountWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRegenerateKubeAccountRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RegenerateKubeAccount(ctx context.Context, body RegenerateKubeAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRegenerateKubeAccountRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveNodeDedicationWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveNodeDedicationRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveNodeDedication(ctx context.Context, body RemoveNodeDedicationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveNodeDedicationRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DedicateNodeWithBody(ctx context.Context, userGroup string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDedicateNodeRequestWithBody(c.Server, userGroup, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DedicateNode(ctx context.Context, userGroup string, body DedicateNodeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDedicateNodeRequest(c.Server, userGroup, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListAllNodesAdmin(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAllNodesAdminRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DisableSandboxWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDisableSandboxRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DisableSandbox(ctx context.Context, body DisableSandboxJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDisableSandboxRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EnableSandboxWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEnableSandboxRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EnableSandbox(ctx context.Context, body EnableSandboxJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEnableSandboxRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CheckNodeStatus(ctx context.Context, node string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCheckNodeStatusRequest(c.Server, node)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListPorts(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListPortsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AttachDiskWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAttachDiskRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AttachDisk(ctx context.Context, body AttachDiskJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAttachDiskRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CloneVmWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCloneVmRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CloneVm(ctx context.Context, body CloneVmJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCloneVmRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListYourVmConfigurationsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListYourVmConfigurationsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SaveVmStateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSaveVmStateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SaveVmState(ctx context.Context, body SaveVmStateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSaveVmStateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetVmConfigurationByNameWithBody(ctx context.Context, vm string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetVmConfigurationByNameRequestWithBody(c.Server, vm, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteVmStateWithBody(ctx context.Context, vm string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteVmStateRequestWithBody(c.Server, vm, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateVmConfigurationWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateVmConfigurationRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateVmConfiguration(ctx context.Context, body CreateVmConfigurationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateVmConfigurationRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteUserSVmAdminWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteUserSVmAdminRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteUserSVmAdmin(ctx context.Context, body DeleteUserSVmAdminJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteUserSVmAdminRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeployVmConfigurationWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeployVmConfigurationRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeployVmConfiguration(ctx context.Context, body DeployVmConfigurationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeployVmConfigurationRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ResumeVmWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewResumeVmRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ResumeVm(ctx context.Context, body ResumeVmJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewResumeVmRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RevertVmWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRevertVmRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RevertVm(ctx context.Context, body RevertVmJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRevertVmRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StartVmWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStartVmRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StartVm(ctx context.Context, body StartVmJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStartVmRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StopVmWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStopVmRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StopVm(ctx context.Context, body StopVmJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStopVmRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SuspendVmWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSuspendVmRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SuspendVm(ctx context.Context, body SuspendVmJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSuspendVmRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListYourVMs(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListYourVMsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListDisksWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListDisksRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListDisks(ctx context.Context, body ListDisksJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListDisksRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListAllVMsAdmin(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAllVMsAdminRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListUserSVMsAdmin(ctx context.Context, email string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListUserSVMsAdminRequest(c.Server, email)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MigrateVmWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMigrateVmRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MigrateVm(ctx context.Context, body MigrateVmJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMigrateVmRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PurgeUserSVMsAdminWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPurgeUserSVMsAdminRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PurgeUserSVMsAdmin(ctx context.Context, body PurgeUserSVMsAdminJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPurgeUserSVMsAdminRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnScaleVmWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnScaleVmRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnScaleVm(ctx context.Context, body UnScaleVmJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnScaleVmRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CheckUserSVmStatusAdmin(ctx context.Context, vm string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCheckUserSVmStatusAdminRequest(c.Server, vm)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RevokeToken(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRevokeTokenRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CheckTokenStatus(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCheckTokenStatusRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTokenWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTokenRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateToken(ctx context.Context, body CreateTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTokenRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUsers(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUsersRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateUserWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateUserRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateUser(ctx context.Context, body CreateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateUserRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateUserWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateUserRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateUser(ctx context.Context, body UpdateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateUserRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UngroupUsersWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUngroupUsersRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UngroupUsers(ctx context.Context, body UngroupUsersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUngroupUsersRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GroupUsersWithBody(ctx context.Context, userGroup string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGroupUsersRequestWithBody(c.Server, userGroup, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GroupUsers(ctx context.Context, userGroup string, body GroupUsersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGroupUsersRequest(c.Server, userGroup, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ResetPasswordAdminWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewResetPasswordAdminRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ResetPasswordAdmin(ctx context.Context, body ResetPasswordAdminJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewResetPasswordAdminRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteUser(ctx context.Context, email string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteUserRequest(c.Server, email)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ValidateLicenseKeyWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewValidateLicenseKeyRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ValidateLicenseKey(ctx context.Context, body ValidateLicenseKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewValidateLicenseKeyRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CheckPasswordRequirements(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCheckPasswordRequirementsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetDefaultBaseImageRequest generates requests for GetDefaultBaseImage
func NewGetDefaultBaseImageRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/default-base-image")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCheckApiVersionRequest generates requests for CheckApiVersion
func NewCheckApiVersionRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/health-check")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteLogsRequest generates requests for DeleteLogs
func NewDeleteLogsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/logs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListLogsRequest generates requests for ListLogs
func NewListLogsRequest(server string, params *ListLogsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/logs/query")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCommitChangesToTheBaseImageRequest calls the generic CommitChangesToTheBaseImage builder with application/json body
func NewCommitChangesToTheBaseImageRequest(server string, body CommitChangesToTheBaseImageJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCommitChangesToTheBaseImageRequestWithBody(server, "application/json", bodyReader)
}

// NewCommitChangesToTheBaseImageRequestWithBody generates requests for CommitChangesToTheBaseImage with any type of body
func NewCommitChangesToTheBaseImageRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/resources/image/commit")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCopyImageRequest calls the generic CopyImage builder with application/json body
func NewCopyImageRequest(server string, body CopyImageJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCopyImageRequestWithBody(server, "application/json", bodyReader)
}

// NewCopyImageRequestWithBody generates requests for CopyImage with any type of body
func NewCopyImageRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/resources/image/copy")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteImageRequest calls the generic DeleteImage builder with application/json body
func NewDeleteImageRequest(server string, body DeleteImageJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteImageRequestWithBody(server, "application/json", bodyReader)
}

// NewDeleteImageRequestWithBody generates requests for DeleteImage with any type of body
func NewDeleteImageRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/resources/image/delete")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGenerateEmptyStorageRequest calls the generic GenerateEmptyStorage builder with application/json body
func NewGenerateEmptyStorageRequest(server string, body GenerateEmptyStorageJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGenerateEmptyStorageRequestWithBody(server, "application/json", bodyReader)
}

// NewGenerateEmptyStorageRequestWithBody generates requests for GenerateEmptyStorage with any type of body
func NewGenerateEmptyStorageRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/resources/image/generate")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListImagesRequest generates requests for ListImages
func NewListImagesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/resources/image/list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListRemoteImagesRequest generates requests for ListRemoteImages
func NewListRemoteImagesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/resources/image/list-remote")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPullImageRequest calls the generic PullImage builder with application/json body
func NewPullImageRequest(server string, body PullImageJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPullImageRequestWithBody(server, "application/json", bodyReader)
}

// NewPullImageRequestWithBody generates requests for PullImage with any type of body
func NewPullImageRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/resources/image/pull")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRenameImageRequest calls the generic RenameImage builder with application/json body
func NewRenameImageRequest(server string, body RenameImageJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRenameImageRequestWithBody(server, "application/json", bodyReader)
}

// NewRenameImageRequestWithBody generates requests for RenameImage with any type of body
func NewRenameImageRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/resources/image/rename")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewResizeImageRequest calls the generic ResizeImage builder with application/json body
func NewResizeImageRequest(server string, body ResizeImageJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewResizeImageRequestWithBody(server, "application/json", bodyReader)
}

// NewResizeImageRequestWithBody generates requests for ResizeImage with any type of body
func NewResizeImageRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/resources/image/resize")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSaveNewBaseImageFromVmRequest calls the generic SaveNewBaseImageFromVm builder with application/json body
func NewSaveNewBaseImageFromVmRequest(server string, body SaveNewBaseImageFromVmJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSaveNewBaseImageFromVmRequestWithBody(server, "application/json", bodyReader)
}

// NewSaveNewBaseImageFromVmRequestWithBody generates requests for SaveNewBaseImageFromVm with any type of body
func NewSaveNewBaseImageFromVmRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/resources/image/save")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUploadAnImageRequestWithBody generates requests for UploadAnImage with any type of body
func NewUploadAnImageRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/resources/image/upload")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCopyIsoRequest calls the generic CopyIso builder with application/json body
func NewCopyIsoRequest(server string, body CopyIsoJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCopyIsoRequestWithBody(server, "application/json", bodyReader)
}

// NewCopyIsoRequestWithBody generates requests for CopyIso with any type of body
func NewCopyIsoRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/resources/iso/copy")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteIsoRequest calls the generic DeleteIso builder with application/json body
func NewDeleteIsoRequest(server string, body DeleteIsoJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteIsoRequestWithBody(server, "application/json", bodyReader)
}

// NewDeleteIsoRequestWithBody generates requests for DeleteIso with any type of body
func NewDeleteIsoRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/resources/iso/delete")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListIsOsInLocalStorageRequest generates requests for ListIsOsInLocalStorage
func NewListIsOsInLocalStorageRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/resources/iso/list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListRemoteIsOsRequest generates requests for ListRemoteIsOs
func NewListRemoteIsOsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/resources/iso/list-remote")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPullIsoRequest calls the generic PullIso builder with application/json body
func NewPullIsoRequest(server string, body PullIsoJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPullIsoRequestWithBody(server, "application/json", bodyReader)
}

// NewPullIsoRequestWithBody generates requests for PullIso with any type of body
func NewPullIsoRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/resources/iso/pull")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRenameIsoRequest calls the generic RenameIso builder with application/json body
func NewRenameIsoRequest(server string, body RenameIsoJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRenameIsoRequestWithBody(server, "application/json", bodyReader)
}

// NewRenameIsoRequestWithBody generates requests for RenameIso with any type of body
func NewRenameIsoRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/resources/iso/rename")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUploadAnIsoRequestWithBody generates requests for UploadAnIso with any type of body
func NewUploadAnIsoRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/resources/iso/upload")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteKubeAccountRequest calls the generic DeleteKubeAccount builder with application/json body
func NewDeleteKubeAccountRequest(server string, body DeleteKubeAccountJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteKubeAccountRequestWithBody(server, "application/json", bodyReader)
}

// NewDeleteKubeAccountRequestWithBody generates requests for DeleteKubeAccount with any type of body
func NewDeleteKubeAccountRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/resources/kube-account")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListKubeAccountsRequest calls the generic ListKubeAccounts builder with application/json body
func NewListKubeAccountsRequest(server string, body ListKubeAccountsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewListKubeAccountsRequestWithBody(server, "application/json", bodyReader)
}

// NewListKubeAccountsRequestWithBody generates requests for ListKubeAccounts with any type of body
func NewListKubeAccountsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/resources/kube-account")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateKubeAccountRequest calls the generic CreateKubeAccount builder with application/json body
func NewCreateKubeAccountRequest(server string, body CreateKubeAccountJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateKubeAccountRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateKubeAccountRequestWithBody generates requests for CreateKubeAccount with any type of body
func NewCreateKubeAccountRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/resources/kube-account")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDownloadKubeconfigRequest calls the generic DownloadKubeconfig builder with application/json body
func NewDownloadKubeconfigRequest(server string, body DownloadKubeconfigJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDownloadKubeconfigRequestWithBody(server, "application/json", bodyReader)
}

// NewDownloadKubeconfigRequestWithBody generates requests for DownloadKubeconfig with any type of body
func NewDownloadKubeconfigRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/resources/kube-account/download")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRegenerateKubeAccountRequest calls the generic RegenerateKubeAccount builder with application/json body
func NewRegenerateKubeAccountRequest(server string, body RegenerateKubeAccountJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRegenerateKubeAccountRequestWithBody(server, "application/json", bodyReader)
}

// NewRegenerateKubeAccountRequestWithBody generates requests for RegenerateKubeAccount with any type of body
func NewRegenerateKubeAccountRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/resources/kube-account/regenerate")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRemoveNodeDedicationRequest calls the generic RemoveNodeDedication builder with application/json body
func NewRemoveNodeDedicationRequest(server string, body RemoveNodeDedicationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRemoveNodeDedicationRequestWithBody(server, "application/json", bodyReader)
}

// NewRemoveNodeDedicationRequestWithBody generates requests for RemoveNodeDedication with any type of body
func NewRemoveNodeDedicationRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/resources/node/groups/$ungrouped")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDedicateNodeRequest calls the generic DedicateNode builder with application/json body
func NewDedicateNodeRequest(server string, userGroup string, body DedicateNodeJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDedicateNodeRequestWithBody(server, userGroup, "application/json", bodyReader)
}

// NewDedicateNodeRequestWithBody generates requests for DedicateNode with any type of body
func NewDedicateNodeRequestWithBody(server string, userGroup string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userGroup", runtime.ParamLocationPath, userGroup)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/resources/node/groups/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListAllNodesAdminRequest generates requests for ListAllNodesAdmin
func NewListAllNodesAdminRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/resources/node/list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDisableSandboxRequest calls the generic DisableSandbox builder with application/json body
func NewDisableSandboxRequest(server string, body DisableSandboxJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDisableSandboxRequestWithBody(server, "application/json", bodyReader)
}

// NewDisableSandboxRequestWithBody generates requests for DisableSandbox with any type of body
func NewDisableSandboxRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/resources/node/sandbox")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewEnableSandboxRequest calls the generic EnableSandbox builder with application/json body
func NewEnableSandboxRequest(server string, body EnableSandboxJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewEnableSandboxRequestWithBody(server, "application/json", bodyReader)
}

// NewEnableSandboxRequestWithBody generates requests for EnableSandbox with any type of body
func NewEnableSandboxRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/resources/node/sandbox")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCheckNodeStatusRequest generates requests for CheckNodeStatus
func NewCheckNodeStatusRequest(server string, node string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "node", runtime.ParamLocationPath, node)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/resources/node/status/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListPortsRequest generates requests for ListPorts
func NewListPortsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/resources/ports")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAttachDiskRequest calls the generic AttachDisk builder with application/json body
func NewAttachDiskRequest(server string, body AttachDiskJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAttachDiskRequestWithBody(server, "application/json", bodyReader)
}

// NewAttachDiskRequestWithBody generates requests for AttachDisk with any type of body
func NewAttachDiskRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/resources/vm/attach-disk")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCloneVmRequest calls the generic CloneVm builder with application/json body
func NewCloneVmRequest(server string, body CloneVmJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCloneVmRequestWithBody(server, "application/json", bodyReader)
}

// NewCloneVmRequestWithBody generates requests for CloneVm with any type of body
func NewCloneVmRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/resources/vm/clone")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListYourVmConfigurationsRequestWithBody generates requests for ListYourVmConfigurations with any type of body
func NewListYourVmConfigurationsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/resources/vm/configs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSaveVmStateRequest calls the generic SaveVmState builder with application/json body
func NewSaveVmStateRequest(server string, body SaveVmStateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSaveVmStateRequestWithBody(server, "application/json", bodyReader)
}

// NewSaveVmStateRequestWithBody generates requests for SaveVmState with any type of body
func NewSaveVmStateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/resources/vm/configs/save-state")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetVmConfigurationByNameRequestWithBody generates requests for GetVmConfigurationByName with any type of body
func NewGetVmConfigurationByNameRequestWithBody(server string, vm string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "vm", runtime.ParamLocationPath, vm)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/resources/vm/configs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteVmStateRequestWithBody generates requests for DeleteVmState with any type of body
func NewDeleteVmStateRequestWithBody(server string, vm string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "vm", runtime.ParamLocationPath, vm)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/resources/vm/configs/%s/delete-state", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateVmConfigurationRequest calls the generic CreateVmConfiguration builder with application/json body
func NewCreateVmConfigurationRequest(server string, body CreateVmConfigurationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateVmConfigurationRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateVmConfigurationRequestWithBody generates requests for CreateVmConfiguration with any type of body
func NewCreateVmConfigurationRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/resources/vm/create")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteUserSVmAdminRequest calls the generic DeleteUserSVmAdmin builder with application/json body
func NewDeleteUserSVmAdminRequest(server string, body DeleteUserSVmAdminJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteUserSVmAdminRequestWithBody(server, "application/json", bodyReader)
}

// NewDeleteUserSVmAdminRequestWithBody generates requests for DeleteUserSVmAdmin with any type of body
func NewDeleteUserSVmAdminRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/resources/vm/delete")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeployVmConfigurationRequest calls the generic DeployVmConfiguration builder with application/json body
func NewDeployVmConfigurationRequest(server string, body DeployVmConfigurationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeployVmConfigurationRequestWithBody(server, "application/json", bodyReader)
}

// NewDeployVmConfigurationRequestWithBody generates requests for DeployVmConfiguration with any type of body
func NewDeployVmConfigurationRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/resources/vm/deploy")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewResumeVmRequest calls the generic ResumeVm builder with application/json body
func NewResumeVmRequest(server string, body ResumeVmJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewResumeVmRequestWithBody(server, "application/json", bodyReader)
}

// NewResumeVmRequestWithBody generates requests for ResumeVm with any type of body
func NewResumeVmRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/resources/vm/exec/resume")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRevertVmRequest calls the generic RevertVm builder with application/json body
func NewRevertVmRequest(server string, body RevertVmJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRevertVmRequestWithBody(server, "application/json", bodyReader)
}

// NewRevertVmRequestWithBody generates requests for RevertVm with any type of body
func NewRevertVmRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/resources/vm/exec/revert")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewStartVmRequest calls the generic StartVm builder with application/json body
func NewStartVmRequest(server string, body StartVmJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewStartVmRequestWithBody(server, "application/json", bodyReader)
}

// NewStartVmRequestWithBody generates requests for StartVm with any type of body
func NewStartVmRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/resources/vm/exec/start")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewStopVmRequest calls the generic StopVm builder with application/json body
func NewStopVmRequest(server string, body StopVmJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewStopVmRequestWithBody(server, "application/json", bodyReader)
}

// NewStopVmRequestWithBody generates requests for StopVm with any type of body
func NewStopVmRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/resources/vm/exec/stop")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSuspendVmRequest calls the generic SuspendVm builder with application/json body
func NewSuspendVmRequest(server string, body SuspendVmJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSuspendVmRequestWithBody(server, "application/json", bodyReader)
}

// NewSuspendVmRequestWithBody generates requests for SuspendVm with any type of body
func NewSuspendVmRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/resources/vm/exec/suspend")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListYourVMsRequest generates requests for ListYourVMs
func NewListYourVMsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/resources/vm/list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListDisksRequest calls the generic ListDisks builder with application/json body
func NewListDisksRequest(server string, body ListDisksJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewListDisksRequestWithBody(server, "application/json", bodyReader)
}

// NewListDisksRequestWithBody generates requests for ListDisks with any type of body
func NewListDisksRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/resources/vm/list-disks")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListAllVMsAdminRequest generates requests for ListAllVMsAdmin
func NewListAllVMsAdminRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/resources/vm/list/all")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListUserSVMsAdminRequest generates requests for ListUserSVMsAdmin
func NewListUserSVMsAdminRequest(server string, email string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "email", runtime.ParamLocationPath, email)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/resources/vm/list/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMigrateVmRequest calls the generic MigrateVm builder with application/json body
func NewMigrateVmRequest(server string, body MigrateVmJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewMigrateVmRequestWithBody(server, "application/json", bodyReader)
}

// NewMigrateVmRequestWithBody generates requests for MigrateVm with any type of body
func NewMigrateVmRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/resources/vm/migrate")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPurgeUserSVMsAdminRequest calls the generic PurgeUserSVMsAdmin builder with application/json body
func NewPurgeUserSVMsAdminRequest(server string, body PurgeUserSVMsAdminJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPurgeUserSVMsAdminRequestWithBody(server, "application/json", bodyReader)
}

// NewPurgeUserSVMsAdminRequestWithBody generates requests for PurgeUserSVMsAdmin with any type of body
func NewPurgeUserSVMsAdminRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/resources/vm/purge")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUnScaleVmRequest calls the generic UnScaleVm builder with application/json body
func NewUnScaleVmRequest(server string, body UnScaleVmJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUnScaleVmRequestWithBody(server, "application/json", bodyReader)
}

// NewUnScaleVmRequestWithBody generates requests for UnScaleVm with any type of body
func NewUnScaleVmRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/resources/vm/scale")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCheckUserSVmStatusAdminRequest generates requests for CheckUserSVmStatusAdmin
func NewCheckUserSVmStatusAdminRequest(server string, vm string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "vm", runtime.ParamLocationPath, vm)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/resources/vm/status/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRevokeTokenRequest generates requests for RevokeToken
func NewRevokeTokenRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/token")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCheckTokenStatusRequest generates requests for CheckTokenStatus
func NewCheckTokenStatusRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/token")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateTokenRequest calls the generic CreateToken builder with application/json body
func NewCreateTokenRequest(server string, body CreateTokenJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateTokenRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateTokenRequestWithBody generates requests for CreateToken with any type of body
func NewCreateTokenRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/token")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetUsersRequest generates requests for GetUsers
func NewGetUsersRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateUserRequest calls the generic CreateUser builder with application/json body
func NewCreateUserRequest(server string, body CreateUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateUserRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateUserRequestWithBody generates requests for CreateUser with any type of body
func NewCreateUserRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUpdateUserRequest calls the generic UpdateUser builder with application/json body
func NewUpdateUserRequest(server string, body UpdateUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateUserRequestWithBody(server, "application/json", bodyReader)
}

// NewUpdateUserRequestWithBody generates requests for UpdateUser with any type of body
func NewUpdateUserRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUngroupUsersRequest calls the generic UngroupUsers builder with application/json body
func NewUngroupUsersRequest(server string, body UngroupUsersJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUngroupUsersRequestWithBody(server, "application/json", bodyReader)
}

// NewUngroupUsersRequestWithBody generates requests for UngroupUsers with any type of body
func NewUngroupUsersRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/groups/$ungrouped")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGroupUsersRequest calls the generic GroupUsers builder with application/json body
func NewGroupUsersRequest(server string, userGroup string, body GroupUsersJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGroupUsersRequestWithBody(server, userGroup, "application/json", bodyReader)
}

// NewGroupUsersRequestWithBody generates requests for GroupUsers with any type of body
func NewGroupUsersRequestWithBody(server string, userGroup string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userGroup", runtime.ParamLocationPath, userGroup)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/groups/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewResetPasswordAdminRequest calls the generic ResetPasswordAdmin builder with application/json body
func NewResetPasswordAdminRequest(server string, body ResetPasswordAdminJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewResetPasswordAdminRequestWithBody(server, "application/json", bodyReader)
}

// NewResetPasswordAdminRequestWithBody generates requests for ResetPasswordAdmin with any type of body
func NewResetPasswordAdminRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/password")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteUserRequest generates requests for DeleteUser
func NewDeleteUserRequest(server string, email string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "email", runtime.ParamLocationPath, email)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewValidateLicenseKeyRequest calls the generic ValidateLicenseKey builder with application/json body
func NewValidateLicenseKeyRequest(server string, body ValidateLicenseKeyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewValidateLicenseKeyRequestWithBody(server, "application/json", bodyReader)
}

// NewValidateLicenseKeyRequestWithBody generates requests for ValidateLicenseKey with any type of body
func NewValidateLicenseKeyRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/validate-license-key")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCheckPasswordRequirementsRequest generates requests for CheckPasswordRequirements
func NewCheckPasswordRequirementsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/validation-requirements")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetDefaultBaseImage request
	GetDefaultBaseImageWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetDefaultBaseImageResponse, error)

	// CheckApiVersion request
	CheckApiVersionWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*CheckApiVersionResponse, error)

	// DeleteLogs request
	DeleteLogsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*DeleteLogsResponse, error)

	// ListLogs request
	ListLogsWithResponse(ctx context.Context, params *ListLogsParams, reqEditors ...RequestEditorFn) (*ListLogsResponse, error)

	// CommitChangesToTheBaseImage request with any body
	CommitChangesToTheBaseImageWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CommitChangesToTheBaseImageResponse, error)

	CommitChangesToTheBaseImageWithResponse(ctx context.Context, body CommitChangesToTheBaseImageJSONRequestBody, reqEditors ...RequestEditorFn) (*CommitChangesToTheBaseImageResponse, error)

	// CopyImage request with any body
	CopyImageWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CopyImageResponse, error)

	CopyImageWithResponse(ctx context.Context, body CopyImageJSONRequestBody, reqEditors ...RequestEditorFn) (*CopyImageResponse, error)

	// DeleteImage request with any body
	DeleteImageWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteImageResponse, error)

	DeleteImageWithResponse(ctx context.Context, body DeleteImageJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteImageResponse, error)

	// GenerateEmptyStorage request with any body
	GenerateEmptyStorageWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GenerateEmptyStorageResponse, error)

	GenerateEmptyStorageWithResponse(ctx context.Context, body GenerateEmptyStorageJSONRequestBody, reqEditors ...RequestEditorFn) (*GenerateEmptyStorageResponse, error)

	// ListImages request
	ListImagesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListImagesResponse, error)

	// ListRemoteImages request
	ListRemoteImagesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListRemoteImagesResponse, error)

	// PullImage request with any body
	PullImageWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PullImageResponse, error)

	PullImageWithResponse(ctx context.Context, body PullImageJSONRequestBody, reqEditors ...RequestEditorFn) (*PullImageResponse, error)

	// RenameImage request with any body
	RenameImageWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RenameImageResponse, error)

	RenameImageWithResponse(ctx context.Context, body RenameImageJSONRequestBody, reqEditors ...RequestEditorFn) (*RenameImageResponse, error)

	// ResizeImage request with any body
	ResizeImageWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ResizeImageResponse, error)

	ResizeImageWithResponse(ctx context.Context, body ResizeImageJSONRequestBody, reqEditors ...RequestEditorFn) (*ResizeImageResponse, error)

	// SaveNewBaseImageFromVm request with any body
	SaveNewBaseImageFromVmWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SaveNewBaseImageFromVmResponse, error)

	SaveNewBaseImageFromVmWithResponse(ctx context.Context, body SaveNewBaseImageFromVmJSONRequestBody, reqEditors ...RequestEditorFn) (*SaveNewBaseImageFromVmResponse, error)

	// UploadAnImage request with any body
	UploadAnImageWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UploadAnImageResponse, error)

	// CopyIso request with any body
	CopyIsoWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CopyIsoResponse, error)

	CopyIsoWithResponse(ctx context.Context, body CopyIsoJSONRequestBody, reqEditors ...RequestEditorFn) (*CopyIsoResponse, error)

	// DeleteIso request with any body
	DeleteIsoWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteIsoResponse, error)

	DeleteIsoWithResponse(ctx context.Context, body DeleteIsoJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteIsoResponse, error)

	// ListIsOsInLocalStorage request
	ListIsOsInLocalStorageWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListIsOsInLocalStorageResponse, error)

	// ListRemoteIsOs request
	ListRemoteIsOsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListRemoteIsOsResponse, error)

	// PullIso request with any body
	PullIsoWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PullIsoResponse, error)

	PullIsoWithResponse(ctx context.Context, body PullIsoJSONRequestBody, reqEditors ...RequestEditorFn) (*PullIsoResponse, error)

	// RenameIso request with any body
	RenameIsoWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RenameIsoResponse, error)

	RenameIsoWithResponse(ctx context.Context, body RenameIsoJSONRequestBody, reqEditors ...RequestEditorFn) (*RenameIsoResponse, error)

	// UploadAnIso request with any body
	UploadAnIsoWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UploadAnIsoResponse, error)

	// DeleteKubeAccount request with any body
	DeleteKubeAccountWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteKubeAccountResponse, error)

	DeleteKubeAccountWithResponse(ctx context.Context, body DeleteKubeAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteKubeAccountResponse, error)

	// ListKubeAccounts request with any body
	ListKubeAccountsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ListKubeAccountsResponse, error)

	ListKubeAccountsWithResponse(ctx context.Context, body ListKubeAccountsJSONRequestBody, reqEditors ...RequestEditorFn) (*ListKubeAccountsResponse, error)

	// CreateKubeAccount request with any body
	CreateKubeAccountWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateKubeAccountResponse, error)

	CreateKubeAccountWithResponse(ctx context.Context, body CreateKubeAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateKubeAccountResponse, error)

	// DownloadKubeconfig request with any body
	DownloadKubeconfigWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DownloadKubeconfigResponse, error)

	DownloadKubeconfigWithResponse(ctx context.Context, body DownloadKubeconfigJSONRequestBody, reqEditors ...RequestEditorFn) (*DownloadKubeconfigResponse, error)

	// RegenerateKubeAccount request with any body
	RegenerateKubeAccountWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RegenerateKubeAccountResponse, error)

	RegenerateKubeAccountWithResponse(ctx context.Context, body RegenerateKubeAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*RegenerateKubeAccountResponse, error)

	// RemoveNodeDedication request with any body
	RemoveNodeDedicationWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RemoveNodeDedicationResponse, error)

	RemoveNodeDedicationWithResponse(ctx context.Context, body RemoveNodeDedicationJSONRequestBody, reqEditors ...RequestEditorFn) (*RemoveNodeDedicationResponse, error)

	// DedicateNode request with any body
	DedicateNodeWithBodyWithResponse(ctx context.Context, userGroup string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DedicateNodeResponse, error)

	DedicateNodeWithResponse(ctx context.Context, userGroup string, body DedicateNodeJSONRequestBody, reqEditors ...RequestEditorFn) (*DedicateNodeResponse, error)

	// ListAllNodesAdmin request
	ListAllNodesAdminWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListAllNodesAdminResponse, error)

	// DisableSandbox request with any body
	DisableSandboxWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DisableSandboxResponse, error)

	DisableSandboxWithResponse(ctx context.Context, body DisableSandboxJSONRequestBody, reqEditors ...RequestEditorFn) (*DisableSandboxResponse, error)

	// EnableSandbox request with any body
	EnableSandboxWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EnableSandboxResponse, error)

	EnableSandboxWithResponse(ctx context.Context, body EnableSandboxJSONRequestBody, reqEditors ...RequestEditorFn) (*EnableSandboxResponse, error)

	// CheckNodeStatus request
	CheckNodeStatusWithResponse(ctx context.Context, node string, reqEditors ...RequestEditorFn) (*CheckNodeStatusResponse, error)

	// ListPorts request
	ListPortsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListPortsResponse, error)

	// AttachDisk request with any body
	AttachDiskWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AttachDiskResponse, error)

	AttachDiskWithResponse(ctx context.Context, body AttachDiskJSONRequestBody, reqEditors ...RequestEditorFn) (*AttachDiskResponse, error)

	// CloneVm request with any body
	CloneVmWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CloneVmResponse, error)

	CloneVmWithResponse(ctx context.Context, body CloneVmJSONRequestBody, reqEditors ...RequestEditorFn) (*CloneVmResponse, error)

	// ListYourVmConfigurations request with any body
	ListYourVmConfigurationsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ListYourVmConfigurationsResponse, error)

	// SaveVmState request with any body
	SaveVmStateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SaveVmStateResponse, error)

	SaveVmStateWithResponse(ctx context.Context, body SaveVmStateJSONRequestBody, reqEditors ...RequestEditorFn) (*SaveVmStateResponse, error)

	// GetVmConfigurationByName request with any body
	GetVmConfigurationByNameWithBodyWithResponse(ctx context.Context, vm string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetVmConfigurationByNameResponse, error)

	// DeleteVmState request with any body
	DeleteVmStateWithBodyWithResponse(ctx context.Context, vm string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteVmStateResponse, error)

	// CreateVmConfiguration request with any body
	CreateVmConfigurationWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateVmConfigurationResponse, error)

	CreateVmConfigurationWithResponse(ctx context.Context, body CreateVmConfigurationJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateVmConfigurationResponse, error)

	// DeleteUserSVmAdmin request with any body
	DeleteUserSVmAdminWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteUserSVmAdminResponse, error)

	DeleteUserSVmAdminWithResponse(ctx context.Context, body DeleteUserSVmAdminJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteUserSVmAdminResponse, error)

	// DeployVmConfiguration request with any body
	DeployVmConfigurationWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeployVmConfigurationResponse, error)

	DeployVmConfigurationWithResponse(ctx context.Context, body DeployVmConfigurationJSONRequestBody, reqEditors ...RequestEditorFn) (*DeployVmConfigurationResponse, error)

	// ResumeVm request with any body
	ResumeVmWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ResumeVmResponse, error)

	ResumeVmWithResponse(ctx context.Context, body ResumeVmJSONRequestBody, reqEditors ...RequestEditorFn) (*ResumeVmResponse, error)

	// RevertVm request with any body
	RevertVmWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RevertVmResponse, error)

	RevertVmWithResponse(ctx context.Context, body RevertVmJSONRequestBody, reqEditors ...RequestEditorFn) (*RevertVmResponse, error)

	// StartVm request with any body
	StartVmWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StartVmResponse, error)

	StartVmWithResponse(ctx context.Context, body StartVmJSONRequestBody, reqEditors ...RequestEditorFn) (*StartVmResponse, error)

	// StopVm request with any body
	StopVmWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StopVmResponse, error)

	StopVmWithResponse(ctx context.Context, body StopVmJSONRequestBody, reqEditors ...RequestEditorFn) (*StopVmResponse, error)

	// SuspendVm request with any body
	SuspendVmWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SuspendVmResponse, error)

	SuspendVmWithResponse(ctx context.Context, body SuspendVmJSONRequestBody, reqEditors ...RequestEditorFn) (*SuspendVmResponse, error)

	// ListYourVMs request
	ListYourVMsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListYourVMsResponse, error)

	// ListDisks request with any body
	ListDisksWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ListDisksResponse, error)

	ListDisksWithResponse(ctx context.Context, body ListDisksJSONRequestBody, reqEditors ...RequestEditorFn) (*ListDisksResponse, error)

	// ListAllVMsAdmin request
	ListAllVMsAdminWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListAllVMsAdminResponse, error)

	// ListUserSVMsAdmin request
	ListUserSVMsAdminWithResponse(ctx context.Context, email string, reqEditors ...RequestEditorFn) (*ListUserSVMsAdminResponse, error)

	// MigrateVm request with any body
	MigrateVmWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MigrateVmResponse, error)

	MigrateVmWithResponse(ctx context.Context, body MigrateVmJSONRequestBody, reqEditors ...RequestEditorFn) (*MigrateVmResponse, error)

	// PurgeUserSVMsAdmin request with any body
	PurgeUserSVMsAdminWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PurgeUserSVMsAdminResponse, error)

	PurgeUserSVMsAdminWithResponse(ctx context.Context, body PurgeUserSVMsAdminJSONRequestBody, reqEditors ...RequestEditorFn) (*PurgeUserSVMsAdminResponse, error)

	// UnScaleVm request with any body
	UnScaleVmWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UnScaleVmResponse, error)

	UnScaleVmWithResponse(ctx context.Context, body UnScaleVmJSONRequestBody, reqEditors ...RequestEditorFn) (*UnScaleVmResponse, error)

	// CheckUserSVmStatusAdmin request
	CheckUserSVmStatusAdminWithResponse(ctx context.Context, vm string, reqEditors ...RequestEditorFn) (*CheckUserSVmStatusAdminResponse, error)

	// RevokeToken request
	RevokeTokenWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*RevokeTokenResponse, error)

	// CheckTokenStatus request
	CheckTokenStatusWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*CheckTokenStatusResponse, error)

	// CreateToken request with any body
	CreateTokenWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTokenResponse, error)

	CreateTokenWithResponse(ctx context.Context, body CreateTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTokenResponse, error)

	// GetUsers request
	GetUsersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetUsersResponse, error)

	// CreateUser request with any body
	CreateUserWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateUserResponse, error)

	CreateUserWithResponse(ctx context.Context, body CreateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateUserResponse, error)

	// UpdateUser request with any body
	UpdateUserWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateUserResponse, error)

	UpdateUserWithResponse(ctx context.Context, body UpdateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateUserResponse, error)

	// UngroupUsers request with any body
	UngroupUsersWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UngroupUsersResponse, error)

	UngroupUsersWithResponse(ctx context.Context, body UngroupUsersJSONRequestBody, reqEditors ...RequestEditorFn) (*UngroupUsersResponse, error)

	// GroupUsers request with any body
	GroupUsersWithBodyWithResponse(ctx context.Context, userGroup string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GroupUsersResponse, error)

	GroupUsersWithResponse(ctx context.Context, userGroup string, body GroupUsersJSONRequestBody, reqEditors ...RequestEditorFn) (*GroupUsersResponse, error)

	// ResetPasswordAdmin request with any body
	ResetPasswordAdminWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ResetPasswordAdminResponse, error)

	ResetPasswordAdminWithResponse(ctx context.Context, body ResetPasswordAdminJSONRequestBody, reqEditors ...RequestEditorFn) (*ResetPasswordAdminResponse, error)

	// DeleteUser request
	DeleteUserWithResponse(ctx context.Context, email string, reqEditors ...RequestEditorFn) (*DeleteUserResponse, error)

	// ValidateLicenseKey request with any body
	ValidateLicenseKeyWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ValidateLicenseKeyResponse, error)

	ValidateLicenseKeyWithResponse(ctx context.Context, body ValidateLicenseKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*ValidateLicenseKeyResponse, error)

	// CheckPasswordRequirements request
	CheckPasswordRequirementsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*CheckPasswordRequirementsResponse, error)
}

type GetDefaultBaseImageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		DefaultBaseImage *string                 `json:"default_base_image,omitempty"`
		Errors           *[]interface{}          `json:"errors,omitempty"`
		Help             *map[string]interface{} `json:"help,omitempty"`
		Message          *string                 `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetDefaultBaseImageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDefaultBaseImageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CheckApiVersionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		ApiVersion *string                 `json:"api_version,omitempty"`
		Errors     *[]interface{}          `json:"errors,omitempty"`
		Help       *map[string]interface{} `json:"help,omitempty"`
		Message    *string                 `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r CheckApiVersionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CheckApiVersionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteLogsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Errors  *[]interface{}          `json:"errors,omitempty"`
		Help    *map[string]interface{} `json:"help,omitempty"`
		Message *string                 `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteLogsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteLogsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListLogsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Errors *[]interface{}          `json:"errors,omitempty"`
		Help   *map[string]interface{} `json:"help,omitempty"`
		Logs   *[]struct {
			CreatedAt  *string `json:"createdAt,omitempty"`
			Id         *string `json:"id,omitempty"`
			LogVersion *string `json:"logVersion,omitempty"`
			Request    *struct {
				Body    *map[string]interface{} `json:"body,omitempty"`
				Headers *struct {
					Accept           *string `json:"accept,omitempty"`
					AcceptEncoding   *string `json:"accept-encoding,omitempty"`
					Connection       *string `json:"connection,omitempty"`
					ContentLength    *string `json:"content-length,omitempty"`
					ContentType      *string `json:"content-type,omitempty"`
					Host             *string `json:"host,omitempty"`
					Platform         *string `json:"platform,omitempty"`
					Release          *string `json:"release,omitempty"`
					UserAgent        *string `json:"user-agent,omitempty"`
					XCliVersion      *string `json:"x-cli-version,omitempty"`
					XForwardedFor    *string `json:"x-forwarded-for,omitempty"`
					XForwardedHost   *string `json:"x-forwarded-host,omitempty"`
					XForwardedPort   *string `json:"x-forwarded-port,omitempty"`
					XForwardedProto  *string `json:"x-forwarded-proto,omitempty"`
					XForwardedServer *string `json:"x-forwarded-server,omitempty"`
					XRealIp          *string `json:"x-real-ip,omitempty"`
				} `json:"headers,omitempty"`
				Method *string `json:"method,omitempty"`
				Url    *string `json:"url,omitempty"`
			} `json:"request,omitempty"`
			Response *struct {
				Body *struct {
					ApiVersion    *string `json:"api_version,omitempty"`
					Authenticated *bool   `json:"authenticated,omitempty"`
					Configs       *[]struct {
						AttachedDisk   *string  `json:"attached_disk,omitempty"`
						GpuPassthrough *bool    `json:"gpu_passthrough,omitempty"`
						IoBoost        *bool    `json:"io_boost,omitempty"`
						IsoImage       *string  `json:"iso_image,omitempty"`
						OrkaBaseImage  *string  `json:"orka_base_image,omitempty"`
						OrkaCpuCore    *float32 `json:"orka_cpu_core,omitempty"`
						OrkaVmName     *string  `json:"orka_vm_name,omitempty"`
						Owner          *string  `json:"owner,omitempty"`
						UseSavedState  *bool    `json:"use_saved_state,omitempty"`
						VcpuCount      *float32 `json:"vcpu_count,omitempty"`
						VncConsole     *bool    `json:"vnc_console,omitempty"`
					} `json:"configs,omitempty"`
					Email                         *string                 `json:"email,omitempty"`
					Errors                        *[]interface{}          `json:"errors,omitempty"`
					FailedVirtualMachineResources *[]interface{}          `json:"failed_virtual_machine_resources,omitempty"`
					Help                          *map[string]interface{} `json:"help,omitempty"`
					IsTokenRevoked                *bool                   `json:"is_token_revoked,omitempty"`
					Message                       *string                 `json:"message,omitempty"`
					VirtualMachineResources       *[]struct {
						BaseImage             *string  `json:"base_image,omitempty"`
						ConfigurationTemplate *string  `json:"configuration_template,omitempty"`
						Cpu                   *float32 `json:"cpu,omitempty"`
						GpuPassthrough        *bool    `json:"gpu_passthrough,omitempty"`
						Image                 *string  `json:"image,omitempty"`
						IoBoost               *bool    `json:"io_boost,omitempty"`
						Owner                 *string  `json:"owner,omitempty"`
						UseSavedState         *bool    `json:"use_saved_state,omitempty"`
						Vcpu                  *float32 `json:"vcpu,omitempty"`
						VirtualMachineName    *string  `json:"virtual_machine_name,omitempty"`
						VmDeploymentStatus    *string  `json:"vm_deployment_status,omitempty"`
					} `json:"virtual_machine_resources,omitempty"`
				} `json:"body,omitempty"`
				Headers *struct {
					AccessControlAllowOrigin *string      `json:"access-control-allow-origin,omitempty"`
					ContentLength            *interface{} `json:"content-length,omitempty"`
					ContentSecurityPolicy    *string      `json:"content-security-policy,omitempty"`
					ContentType              *string      `json:"content-type,omitempty"`
					Etag                     *string      `json:"etag,omitempty"`
					XContentTypeOptions      *string      `json:"x-content-type-options,omitempty"`
				} `json:"headers,omitempty"`
				StatusCode *float32 `json:"statusCode,omitempty"`
			} `json:"response,omitempty"`
			User *struct {
				Email *string `json:"email,omitempty"`
				Id    *string `json:"id,omitempty"`
			} `json:"user,omitempty"`
		} `json:"logs,omitempty"`
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListLogsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListLogsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CommitChangesToTheBaseImageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Errors  *[]interface{}          `json:"errors,omitempty"`
		Help    *map[string]interface{} `json:"help,omitempty"`
		Message *string                 `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r CommitChangesToTheBaseImageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CommitChangesToTheBaseImageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CopyImageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Errors  *[]interface{}          `json:"errors,omitempty"`
		Help    *map[string]interface{} `json:"help,omitempty"`
		Message *string                 `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r CopyImageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CopyImageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteImageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Errors  *[]interface{}          `json:"errors,omitempty"`
		Help    *map[string]interface{} `json:"help,omitempty"`
		Message *string                 `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteImageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteImageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GenerateEmptyStorageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Errors  *[]interface{}          `json:"errors,omitempty"`
		Help    *map[string]interface{} `json:"help,omitempty"`
		Message *string                 `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GenerateEmptyStorageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GenerateEmptyStorageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListImagesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Errors          *[]interface{}          `json:"errors,omitempty"`
		Help            *map[string]interface{} `json:"help,omitempty"`
		ImageAttributes *[]struct {
			DateAdded *string `json:"date_added,omitempty"`
			Image     *string `json:"image,omitempty"`
			ImageSize *string `json:"image_size,omitempty"`
			Modified  *string `json:"modified,omitempty"`
			Owner     *string `json:"owner,omitempty"`
		} `json:"image_attributes,omitempty"`
		Images  *[]string `json:"images,omitempty"`
		Message *string   `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListImagesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListImagesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListRemoteImagesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Errors  *[]interface{}          `json:"errors,omitempty"`
		Help    *map[string]interface{} `json:"help,omitempty"`
		Images  *[]string               `json:"images,omitempty"`
		Message *string                 `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListRemoteImagesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListRemoteImagesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PullImageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Errors  *[]interface{}          `json:"errors,omitempty"`
		Help    *map[string]interface{} `json:"help,omitempty"`
		Message *string                 `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r PullImageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PullImageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RenameImageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Errors  *[]interface{}          `json:"errors,omitempty"`
		Help    *map[string]interface{} `json:"help,omitempty"`
		Message *string                 `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r RenameImageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RenameImageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ResizeImageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Errors *[]interface{}          `json:"errors,omitempty"`
		Help   *map[string]interface{} `json:"help,omitempty"`
		Logs   *[]struct {
			Channel *string `json:"channel,omitempty"`
			Message *string `json:"message,omitempty"`
		} `json:"logs,omitempty"`
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ResizeImageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ResizeImageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SaveNewBaseImageFromVmResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Errors  *[]interface{}          `json:"errors,omitempty"`
		Help    *map[string]interface{} `json:"help,omitempty"`
		Message *string                 `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r SaveNewBaseImageFromVmResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SaveNewBaseImageFromVmResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UploadAnImageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Errors  *[]interface{}          `json:"errors,omitempty"`
		Help    *map[string]interface{} `json:"help,omitempty"`
		Message *string                 `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r UploadAnImageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UploadAnImageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CopyIsoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Errors  *[]interface{}          `json:"errors,omitempty"`
		Help    *map[string]interface{} `json:"help,omitempty"`
		Message *string                 `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r CopyIsoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CopyIsoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteIsoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Errors  *[]interface{}          `json:"errors,omitempty"`
		Help    *map[string]interface{} `json:"help,omitempty"`
		Message *string                 `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteIsoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteIsoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListIsOsInLocalStorageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Errors        *[]interface{}          `json:"errors,omitempty"`
		Help          *map[string]interface{} `json:"help,omitempty"`
		IsoAttributes *[]struct {
			Iso      *string `json:"iso,omitempty"`
			IsoSize  *string `json:"iso_size,omitempty"`
			Modified *string `json:"modified,omitempty"`
		} `json:"iso_attributes,omitempty"`
		Isos    *[]string `json:"isos,omitempty"`
		Message *string   `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListIsOsInLocalStorageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListIsOsInLocalStorageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListRemoteIsOsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Errors  *[]interface{}          `json:"errors,omitempty"`
		Help    *map[string]interface{} `json:"help,omitempty"`
		Isos    *[]string               `json:"isos,omitempty"`
		Message *string                 `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListRemoteIsOsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListRemoteIsOsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PullIsoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Errors  *[]interface{}          `json:"errors,omitempty"`
		Help    *map[string]interface{} `json:"help,omitempty"`
		Message *string                 `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r PullIsoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PullIsoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RenameIsoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Errors  *[]interface{}          `json:"errors,omitempty"`
		Help    *map[string]interface{} `json:"help,omitempty"`
		Message *string                 `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r RenameIsoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RenameIsoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UploadAnIsoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Errors  *[]interface{}          `json:"errors,omitempty"`
		Help    *map[string]interface{} `json:"help,omitempty"`
		Message *string                 `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r UploadAnIsoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UploadAnIsoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteKubeAccountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Errors  *[]interface{}          `json:"errors,omitempty"`
		Help    *map[string]interface{} `json:"help,omitempty"`
		Message *string                 `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteKubeAccountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteKubeAccountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListKubeAccountsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Errors          *[]interface{}          `json:"errors,omitempty"`
		Help            *map[string]interface{} `json:"help,omitempty"`
		Message         *string                 `json:"message,omitempty"`
		ServiceAccounts *[]string               `json:"serviceAccounts,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListKubeAccountsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListKubeAccountsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateKubeAccountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Errors     *[]interface{}          `json:"errors,omitempty"`
		Help       *map[string]interface{} `json:"help,omitempty"`
		Kubeconfig *string                 `json:"kubeconfig,omitempty"`
		Message    *string                 `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r CreateKubeAccountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateKubeAccountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DownloadKubeconfigResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Errors     *[]interface{}          `json:"errors,omitempty"`
		Help       *map[string]interface{} `json:"help,omitempty"`
		Kubeconfig *string                 `json:"kubeconfig,omitempty"`
		Message    *string                 `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DownloadKubeconfigResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DownloadKubeconfigResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RegenerateKubeAccountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Errors     *[]interface{}          `json:"errors,omitempty"`
		Help       *map[string]interface{} `json:"help,omitempty"`
		Kubeconfig *string                 `json:"kubeconfig,omitempty"`
		Message    *string                 `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r RegenerateKubeAccountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RegenerateKubeAccountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveNodeDedicationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Details *[]struct {
			Detail *string `json:"detail,omitempty"`
			Node   *string `json:"node,omitempty"`
		} `json:"details,omitempty"`
		Errors  *[]interface{}          `json:"errors,omitempty"`
		Help    *map[string]interface{} `json:"help,omitempty"`
		Message *string                 `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r RemoveNodeDedicationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveNodeDedicationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DedicateNodeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Details *[]struct {
			Detail *string `json:"detail,omitempty"`
			Node   *string `json:"node,omitempty"`
		} `json:"details,omitempty"`
		Errors  *[]interface{}          `json:"errors,omitempty"`
		Help    *map[string]interface{} `json:"help,omitempty"`
		Message *string                 `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DedicateNodeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DedicateNodeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListAllNodesAdminResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ListAllNodesAdminResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAllNodesAdminResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DisableSandboxResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Errors  *[]interface{}          `json:"errors,omitempty"`
		Help    *map[string]interface{} `json:"help,omitempty"`
		Message *string                 `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DisableSandboxResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DisableSandboxResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EnableSandboxResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Errors  *[]interface{}          `json:"errors,omitempty"`
		Help    *map[string]interface{} `json:"help,omitempty"`
		Message *string                 `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r EnableSandboxResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EnableSandboxResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CheckNodeStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Errors     *[]interface{}          `json:"errors,omitempty"`
		Help       *map[string]interface{} `json:"help,omitempty"`
		Message    *string                 `json:"message,omitempty"`
		NodeStatus *struct {
			Cpu      *float32 `json:"cpu,omitempty"`
			Memory   *string  `json:"memory,omitempty"`
			NodeName *string  `json:"nodeName,omitempty"`
			Sandbox  *string  `json:"sandbox,omitempty"`
			Status   *string  `json:"status,omitempty"`
		} `json:"node_status,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r CheckNodeStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CheckNodeStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListPortsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Errors        *[]interface{}          `json:"errors,omitempty"`
		Help          *map[string]interface{} `json:"help,omitempty"`
		Message       *string                 `json:"message,omitempty"`
		ReservedPorts *[]struct {
			GuestPort    *float32 `json:"guest_port,omitempty"`
			HostPort     *float32 `json:"host_port,omitempty"`
			OrkaNodeName *string  `json:"orka_node_name,omitempty"`
			Protocol     *string  `json:"protocol,omitempty"`
		} `json:"reserved_ports,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListPortsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListPortsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AttachDiskResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		DeployVirtualMachine *string                 `json:"deploy_virtual_machine,omitempty"`
		Errors               *[]interface{}          `json:"errors,omitempty"`
		Help                 *map[string]interface{} `json:"help,omitempty"`
		Message              *string                 `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r AttachDiskResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AttachDiskResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CloneVmResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Errors       *[]interface{}          `json:"errors,omitempty"`
		Help         *map[string]interface{} `json:"help,omitempty"`
		Message      *string                 `json:"message,omitempty"`
		PortWarnings *[]interface{}          `json:"port_warnings,omitempty"`
		VmId         *string                 `json:"vm_id,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r CloneVmResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CloneVmResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListYourVmConfigurationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Configs *[]struct {
			AttachedDisk   *string  `json:"attached_disk,omitempty"`
			GpuPassthrough *bool    `json:"gpu_passthrough,omitempty"`
			IoBoost        *bool    `json:"io_boost,omitempty"`
			IsoImage       *string  `json:"iso_image,omitempty"`
			OrkaBaseImage  *string  `json:"orka_base_image,omitempty"`
			OrkaCpuCore    *float32 `json:"orka_cpu_core,omitempty"`
			OrkaVmName     *string  `json:"orka_vm_name,omitempty"`
			Owner          *string  `json:"owner,omitempty"`
			UseSavedState  *bool    `json:"use_saved_state,omitempty"`
			VcpuCount      *float32 `json:"vcpu_count,omitempty"`
			VncConsole     *bool    `json:"vnc_console,omitempty"`
		} `json:"configs,omitempty"`
		Errors  *[]interface{}          `json:"errors,omitempty"`
		Help    *map[string]interface{} `json:"help,omitempty"`
		Message *string                 `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListYourVmConfigurationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListYourVmConfigurationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SaveVmStateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Errors *[]interface{} `json:"errors,omitempty"`
		Help   *struct {
			Info *string `json:"info,omitempty"`
		} `json:"help,omitempty"`
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r SaveVmStateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SaveVmStateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetVmConfigurationByNameResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Configs *[]struct {
			AttachedDisk   *string  `json:"attached_disk,omitempty"`
			GpuPassthrough *bool    `json:"gpu_passthrough,omitempty"`
			IoBoost        *bool    `json:"io_boost,omitempty"`
			IsoImage       *string  `json:"iso_image,omitempty"`
			OrkaBaseImage  *string  `json:"orka_base_image,omitempty"`
			OrkaCpuCore    *float32 `json:"orka_cpu_core,omitempty"`
			OrkaVmName     *string  `json:"orka_vm_name,omitempty"`
			Owner          *string  `json:"owner,omitempty"`
			UseSavedState  *bool    `json:"use_saved_state,omitempty"`
			VncConsole     *bool    `json:"vnc_console,omitempty"`
		} `json:"configs,omitempty"`
		Errors  *[]interface{}          `json:"errors,omitempty"`
		Help    *map[string]interface{} `json:"help,omitempty"`
		Message *string                 `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetVmConfigurationByNameResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetVmConfigurationByNameResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteVmStateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Errors *[]interface{} `json:"errors,omitempty"`
		Help   *struct {
			Info *string `json:"info,omitempty"`
		} `json:"help,omitempty"`
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteVmStateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteVmStateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateVmConfigurationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		Errors *[]interface{} `json:"errors,omitempty"`
		Help   *struct {
			DeployVirtualMachine         *string `json:"deploy_virtual_machine,omitempty"`
			RequiredRequestDataForDeploy *struct {
				OrkaNodeName *string `json:"orka_node_name,omitempty"`
				OrkaVmName   *string `json:"orka_vm_name,omitempty"`
			} `json:"required_request_data_for_deploy,omitempty"`
		} `json:"help,omitempty"`
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r CreateVmConfigurationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateVmConfigurationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteUserSVmAdminResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Errors *[]interface{} `json:"errors,omitempty"`
		Help   *struct {
			DeployVirtualMachine         *string `json:"deploy_virtual_machine,omitempty"`
			ListOrkaNodes                *string `json:"list_orka_nodes,omitempty"`
			RequiredRequestDataForDeploy *struct {
				OrkaVmName *string `json:"orka_vm_name,omitempty"`
			} `json:"required_request_data_for_deploy,omitempty"`
		} `json:"help,omitempty"`
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteUserSVmAdminResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteUserSVmAdminResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeployVmConfigurationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Errors *[]interface{} `json:"errors,omitempty"`
		Help   *struct {
			DataForVirtualMachineExecTasks *struct {
				OrkaVmName *string `json:"orka_vm_name,omitempty"`
			} `json:"data_for_virtual_machine_exec_tasks,omitempty"`
			ResumeVirtualMachine  *string `json:"resume_virtual_machine,omitempty"`
			StartVirtualMachine   *string `json:"start_virtual_machine,omitempty"`
			StopVirtualMachine    *string `json:"stop_virtual_machine,omitempty"`
			SuspendVirtualMachine *string `json:"suspend_virtual_machine,omitempty"`
			VirtualMachineVnc     *string `json:"virtual_machine_vnc,omitempty"`
		} `json:"help,omitempty"`
		HostCpu         *string        `json:"host_cpu,omitempty"`
		Ip              *string        `json:"ip,omitempty"`
		Message         *string        `json:"message,omitempty"`
		PortWarnings    *[]interface{} `json:"port_warnings,omitempty"`
		Ram             *string        `json:"ram,omitempty"`
		ScreenSharePort *string        `json:"screen_share_port,omitempty"`
		SshPort         *string        `json:"ssh_port,omitempty"`
		Vcpu            *string        `json:"vcpu,omitempty"`
		VmId            *string        `json:"vm_id,omitempty"`
		VncPort         *string        `json:"vnc_port,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DeployVmConfigurationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeployVmConfigurationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ResumeVmResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Errors *[]interface{} `json:"errors,omitempty"`
		Help   *struct {
			DataForVirtualMachineExecTasks *struct {
				OrkaVmName *string `json:"orka_vm_name,omitempty"`
			} `json:"data_for_virtual_machine_exec_tasks,omitempty"`
			ResumeVirtualMachine    *string `json:"resume_virtual_machine,omitempty"`
			RevertVirtualMachine    *string `json:"revert_virtual_machine,omitempty"`
			SaveVirtualMachineState *string `json:"save_virtual_machine_state,omitempty"`
			StartVirtualMachine     *string `json:"start_virtual_machine,omitempty"`
			StopVirtualMachine      *string `json:"stop_virtual_machine,omitempty"`
			SuspendVirtualMachine   *string `json:"suspend_virtual_machine,omitempty"`
		} `json:"help,omitempty"`
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ResumeVmResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ResumeVmResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RevertVmResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Errors *[]interface{} `json:"errors,omitempty"`
		Help   *struct {
			DataForVirtualMachineExecTasks *struct {
				OrkaNodeName *string `json:"orka_node_name,omitempty"`
				OrkaVmName   *string `json:"orka_vm_name,omitempty"`
			} `json:"data_for_virtual_machine_exec_tasks,omitempty"`
			ResumeVirtualMachine    *string `json:"resume_virtual_machine,omitempty"`
			RevertVirtualMachine    *string `json:"revert_virtual_machine,omitempty"`
			SaveVirtualMachineState *string `json:"save_virtual_machine_state,omitempty"`
			StartVirtualMachine     *string `json:"start_virtual_machine,omitempty"`
			StopVirtualMachine      *string `json:"stop_virtual_machine,omitempty"`
			SuspendVirtualMachine   *string `json:"suspend_virtual_machine,omitempty"`
			VirtualMachineVnc       *string `json:"virtual_machine_vnc,omitempty"`
		} `json:"help,omitempty"`
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r RevertVmResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RevertVmResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StartVmResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Errors *[]interface{} `json:"errors,omitempty"`
		Help   *struct {
			DataForVirtualMachineExecTasks *struct {
				OrkaVmName *string `json:"orka_vm_name,omitempty"`
			} `json:"data_for_virtual_machine_exec_tasks,omitempty"`
			ResumeVirtualMachine    *string `json:"resume_virtual_machine,omitempty"`
			RevertVirtualMachine    *string `json:"revert_virtual_machine,omitempty"`
			SaveVirtualMachineState *string `json:"save_virtual_machine_state,omitempty"`
			StartVirtualMachine     *string `json:"start_virtual_machine,omitempty"`
			StopVirtualMachine      *string `json:"stop_virtual_machine,omitempty"`
			SuspendVirtualMachine   *string `json:"suspend_virtual_machine,omitempty"`
		} `json:"help,omitempty"`
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r StartVmResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StartVmResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StopVmResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Errors *[]interface{} `json:"errors,omitempty"`
		Help   *struct {
			DataForVirtualMachineExecTasks *struct {
				OrkaNodeName *string `json:"orka_node_name,omitempty"`
				OrkaVmName   *string `json:"orka_vm_name,omitempty"`
			} `json:"data_for_virtual_machine_exec_tasks,omitempty"`
			ResumeVirtualMachine    *string `json:"resume_virtual_machine,omitempty"`
			RevertVirtualMachine    *string `json:"revert_virtual_machine,omitempty"`
			SaveVirtualMachineState *string `json:"save_virtual_machine_state,omitempty"`
			StartVirtualMachine     *string `json:"start_virtual_machine,omitempty"`
			StopVirtualMachine      *string `json:"stop_virtual_machine,omitempty"`
			SuspendVirtualMachine   *string `json:"suspend_virtual_machine,omitempty"`
			VirtualMachineVnc       *string `json:"virtual_machine_vnc,omitempty"`
		} `json:"help,omitempty"`
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r StopVmResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StopVmResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SuspendVmResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Errors *[]interface{} `json:"errors,omitempty"`
		Help   *struct {
			DataForVirtualMachineExecTasks *struct {
				OrkaNodeName *string `json:"orka_node_name,omitempty"`
				OrkaVmName   *string `json:"orka_vm_name,omitempty"`
			} `json:"data_for_virtual_machine_exec_tasks,omitempty"`
			ResumeVirtualMachine    *string `json:"resume_virtual_machine,omitempty"`
			RevertVirtualMachine    *string `json:"revert_virtual_machine,omitempty"`
			SaveVirtualMachineState *string `json:"save_virtual_machine_state,omitempty"`
			StartVirtualMachine     *string `json:"start_virtual_machine,omitempty"`
			StopVirtualMachine      *string `json:"stop_virtual_machine,omitempty"`
			SuspendVirtualMachine   *string `json:"suspend_virtual_machine,omitempty"`
			VirtualMachineVnc       *string `json:"virtual_machine_vnc,omitempty"`
		} `json:"help,omitempty"`
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r SuspendVmResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SuspendVmResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListYourVMsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Errors                  *[]interface{}          `json:"errors,omitempty"`
		Help                    *map[string]interface{} `json:"help,omitempty"`
		Message                 *string                 `json:"message,omitempty"`
		VirtualMachineResources *[]struct {
			BaseImage             *string  `json:"base_image,omitempty"`
			ConfigurationTemplate *string  `json:"configuration_template,omitempty"`
			Cpu                   *float32 `json:"cpu,omitempty"`
			GpuPassthrough        *bool    `json:"gpu_passthrough,omitempty"`
			Image                 *string  `json:"image,omitempty"`
			IoBoost               *bool    `json:"io_boost,omitempty"`
			Owner                 *string  `json:"owner,omitempty"`
			Status                *[]struct {
				RAM                   *string  `json:"RAM,omitempty"`
				BaseImage             *string  `json:"base_image,omitempty"`
				ConfigurationTemplate *string  `json:"configuration_template,omitempty"`
				Cpu                   *float32 `json:"cpu,omitempty"`
				CreationTimestamp     *string  `json:"creationTimestamp,omitempty"`
				Image                 *string  `json:"image,omitempty"`
				IoBoost               *bool    `json:"io_boost,omitempty"`
				NodeLocation          *string  `json:"node_location,omitempty"`
				NodeStatus            *string  `json:"node_status,omitempty"`
				Owner                 *string  `json:"owner,omitempty"`
				ReservedPorts         *[]struct {
					GuestPort *float32 `json:"guest_port,omitempty"`
					HostPort  *float32 `json:"host_port,omitempty"`
					Protocol  *string  `json:"protocol,omitempty"`
				} `json:"reserved_ports,omitempty"`
				ScreenSharingPort  *string  `json:"screen_sharing_port,omitempty"`
				SshPort            *string  `json:"ssh_port,omitempty"`
				UseSavedState      *bool    `json:"use_saved_state,omitempty"`
				Vcpu               *float32 `json:"vcpu,omitempty"`
				VirtualMachineId   *string  `json:"virtual_machine_id,omitempty"`
				VirtualMachineIp   *string  `json:"virtual_machine_ip,omitempty"`
				VirtualMachineName *string  `json:"virtual_machine_name,omitempty"`
				VmStatus           *string  `json:"vm_status,omitempty"`
				VncPort            *string  `json:"vnc_port,omitempty"`
			} `json:"status,omitempty"`
			UseSavedState      *bool    `json:"use_saved_state,omitempty"`
			Vcpu               *float32 `json:"vcpu,omitempty"`
			VirtualMachineName *string  `json:"virtual_machine_name,omitempty"`
			VmDeploymentStatus *string  `json:"vm_deployment_status,omitempty"`
		} `json:"virtual_machine_resources,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListYourVMsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListYourVMsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListDisksResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Drives *[]struct {
			Device *string `json:"device,omitempty"`
			Source *string `json:"source,omitempty"`
			Target *string `json:"target,omitempty"`
			Type   *string `json:"type,omitempty"`
		} `json:"drives,omitempty"`
		Errors  *[]interface{}          `json:"errors,omitempty"`
		Help    *map[string]interface{} `json:"help,omitempty"`
		Message *string                 `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListDisksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListDisksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListAllVMsAdminResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Errors                  *[]interface{}          `json:"errors,omitempty"`
		Help                    *map[string]interface{} `json:"help,omitempty"`
		Message                 *string                 `json:"message,omitempty"`
		VirtualMachineResources *[]struct {
			BaseImage             *string  `json:"base_image,omitempty"`
			ConfigurationTemplate *string  `json:"configuration_template,omitempty"`
			Cpu                   *float32 `json:"cpu,omitempty"`
			GpuPassthrough        *bool    `json:"gpu_passthrough,omitempty"`
			Image                 *string  `json:"image,omitempty"`
			IoBoost               *bool    `json:"io_boost,omitempty"`
			Owner                 *string  `json:"owner,omitempty"`
			Status                *[]struct {
				RAM                   *string  `json:"RAM,omitempty"`
				BaseImage             *string  `json:"base_image,omitempty"`
				ConfigurationTemplate *string  `json:"configuration_template,omitempty"`
				Cpu                   *float32 `json:"cpu,omitempty"`
				CreationTimestamp     *string  `json:"creationTimestamp,omitempty"`
				Image                 *string  `json:"image,omitempty"`
				IoBoost               *bool    `json:"io_boost,omitempty"`
				NodeLocation          *string  `json:"node_location,omitempty"`
				NodeStatus            *string  `json:"node_status,omitempty"`
				Owner                 *string  `json:"owner,omitempty"`
				ReservedPorts         *[]struct {
					GuestPort *float32 `json:"guest_port,omitempty"`
					HostPort  *float32 `json:"host_port,omitempty"`
					Protocol  *string  `json:"protocol,omitempty"`
				} `json:"reserved_ports,omitempty"`
				ScreenSharingPort  *string  `json:"screen_sharing_port,omitempty"`
				SshPort            *string  `json:"ssh_port,omitempty"`
				UseSavedState      *bool    `json:"use_saved_state,omitempty"`
				Vcpu               *float32 `json:"vcpu,omitempty"`
				VirtualMachineId   *string  `json:"virtual_machine_id,omitempty"`
				VirtualMachineIp   *string  `json:"virtual_machine_ip,omitempty"`
				VirtualMachineName *string  `json:"virtual_machine_name,omitempty"`
				VmStatus           *string  `json:"vm_status,omitempty"`
				VncPort            *string  `json:"vnc_port,omitempty"`
			} `json:"status,omitempty"`
			UseSavedState      *bool    `json:"use_saved_state,omitempty"`
			Vcpu               *float32 `json:"vcpu,omitempty"`
			VirtualMachineName *string  `json:"virtual_machine_name,omitempty"`
			VmDeploymentStatus *string  `json:"vm_deployment_status,omitempty"`
		} `json:"virtual_machine_resources,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListAllVMsAdminResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAllVMsAdminResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListUserSVMsAdminResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Errors                  *[]interface{}          `json:"errors,omitempty"`
		Help                    *map[string]interface{} `json:"help,omitempty"`
		Message                 *string                 `json:"message,omitempty"`
		VirtualMachineResources *[]struct {
			BaseImage             *string  `json:"base_image,omitempty"`
			ConfigurationTemplate *string  `json:"configuration_template,omitempty"`
			Cpu                   *float32 `json:"cpu,omitempty"`
			GpuPassthrough        *bool    `json:"gpu_passthrough,omitempty"`
			Image                 *string  `json:"image,omitempty"`
			IoBoost               *bool    `json:"io_boost,omitempty"`
			Owner                 *string  `json:"owner,omitempty"`
			Status                *[]struct {
				RAM                   *string  `json:"RAM,omitempty"`
				BaseImage             *string  `json:"base_image,omitempty"`
				ConfigurationTemplate *string  `json:"configuration_template,omitempty"`
				Cpu                   *float32 `json:"cpu,omitempty"`
				CreationTimestamp     *string  `json:"creationTimestamp,omitempty"`
				Image                 *string  `json:"image,omitempty"`
				IoBoost               *bool    `json:"io_boost,omitempty"`
				NodeLocation          *string  `json:"node_location,omitempty"`
				NodeStatus            *string  `json:"node_status,omitempty"`
				Owner                 *string  `json:"owner,omitempty"`
				ReservedPorts         *[]struct {
					GuestPort *float32 `json:"guest_port,omitempty"`
					HostPort  *float32 `json:"host_port,omitempty"`
					Protocol  *string  `json:"protocol,omitempty"`
				} `json:"reserved_ports,omitempty"`
				ScreenSharingPort  *string  `json:"screen_sharing_port,omitempty"`
				SshPort            *string  `json:"ssh_port,omitempty"`
				UseSavedState      *bool    `json:"use_saved_state,omitempty"`
				Vcpu               *float32 `json:"vcpu,omitempty"`
				VirtualMachineId   *string  `json:"virtual_machine_id,omitempty"`
				VirtualMachineIp   *string  `json:"virtual_machine_ip,omitempty"`
				VirtualMachineName *string  `json:"virtual_machine_name,omitempty"`
				VmStatus           *string  `json:"vm_status,omitempty"`
				VncPort            *string  `json:"vnc_port,omitempty"`
			} `json:"status,omitempty"`
			UseSavedState      *bool    `json:"use_saved_state,omitempty"`
			Vcpu               *float32 `json:"vcpu,omitempty"`
			VirtualMachineName *string  `json:"virtual_machine_name,omitempty"`
			VmDeploymentStatus *string  `json:"vm_deployment_status,omitempty"`
		} `json:"virtual_machine_resources,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListUserSVMsAdminResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListUserSVMsAdminResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MigrateVmResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Errors       *[]interface{}          `json:"errors,omitempty"`
		Help         *map[string]interface{} `json:"help,omitempty"`
		Message      *string                 `json:"message,omitempty"`
		PortWarnings *[]interface{}          `json:"port_warnings,omitempty"`
		VmId         *string                 `json:"vm_id,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r MigrateVmResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MigrateVmResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PurgeUserSVMsAdminResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Errors *[]interface{} `json:"errors,omitempty"`
		Help   *struct {
			CreateVirtualMachineConfiguration *string `json:"create_virtual_machine_configuration,omitempty"`
			DeployVirtualMachine              *string `json:"deploy_virtual_machine,omitempty"`
			ListOrkaNodes                     *string `json:"list_orka_nodes,omitempty"`
			RequiredRequestDataForCreate      *struct {
				OrkaBaseImg *string `json:"orka_base_img,omitempty"`
				OrkaImage   *string `json:"orka_image,omitempty"`
				OrkaVmName  *string `json:"orka_vm_name,omitempty"`
			} `json:"required_request_data_for_create,omitempty"`
			RequiredRequestDataForDeploy *struct {
				OrkaNodeName *string `json:"orka_node_name,omitempty"`
				OrkaVmName   *string `json:"orka_vm_name,omitempty"`
			} `json:"required_request_data_for_deploy,omitempty"`
		} `json:"help,omitempty"`
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r PurgeUserSVMsAdminResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PurgeUserSVMsAdminResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UnScaleVmResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Errors  *[]interface{}          `json:"errors,omitempty"`
		Help    *map[string]interface{} `json:"help,omitempty"`
		Message *string                 `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r UnScaleVmResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UnScaleVmResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CheckUserSVmStatusAdminResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Errors                  *[]interface{}          `json:"errors,omitempty"`
		Help                    *map[string]interface{} `json:"help,omitempty"`
		Message                 *string                 `json:"message,omitempty"`
		VirtualMachineResources *[]struct {
			BaseImage             *string  `json:"base_image,omitempty"`
			ConfigurationTemplate *string  `json:"configuration_template,omitempty"`
			Cpu                   *float32 `json:"cpu,omitempty"`
			Image                 *string  `json:"image,omitempty"`
			IoBoost               *bool    `json:"io_boost,omitempty"`
			Owner                 *string  `json:"owner,omitempty"`
			UseSavedState         *bool    `json:"use_saved_state,omitempty"`
			Vcpu                  *float32 `json:"vcpu,omitempty"`
			VirtualMachineName    *string  `json:"virtual_machine_name,omitempty"`
			VmDeploymentStatus    *string  `json:"vm_deployment_status,omitempty"`
		} `json:"virtual_machine_resources,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r CheckUserSVmStatusAdminResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CheckUserSVmStatusAdminResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RevokeTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Errors        *[]interface{}          `json:"errors,omitempty"`
		Help          *map[string]interface{} `json:"help,omitempty"`
		Message       *string                 `json:"message,omitempty"`
		TokensRevoked *float32                `json:"tokensRevoked,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r RevokeTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RevokeTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CheckTokenStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Authenticated  *bool                   `json:"authenticated,omitempty"`
		Email          *string                 `json:"email,omitempty"`
		Errors         *[]interface{}          `json:"errors,omitempty"`
		Help           *map[string]interface{} `json:"help,omitempty"`
		IsTokenRevoked *bool                   `json:"is_token_revoked,omitempty"`
		Message        *string                 `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r CheckTokenStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CheckTokenStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Errors  *[]interface{}          `json:"errors,omitempty"`
		Help    *map[string]interface{} `json:"help,omitempty"`
		Message *string                 `json:"message,omitempty"`
		Token   *string                 `json:"token,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r CreateTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Errors    *[]interface{}          `json:"errors,omitempty"`
		Help      *map[string]interface{} `json:"help,omitempty"`
		Message   *string                 `json:"message,omitempty"`
		UserCount *float32                `json:"user_count,omitempty"`
		UserList  *[]string               `json:"user_list,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetUsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		Email   *string                 `json:"email,omitempty"`
		Errors  *[]interface{}          `json:"errors,omitempty"`
		Group   *string                 `json:"group,omitempty"`
		Help    *map[string]interface{} `json:"help,omitempty"`
		Message *string                 `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r CreateUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Errors              *[]interface{}          `json:"errors,omitempty"`
		Help                *map[string]interface{} `json:"help,omitempty"`
		Message             *string                 `json:"message,omitempty"`
		RecordsUpdatedCount *float32                `json:"records_updated_count,omitempty"`
		UserEmail           *string                 `json:"user_email,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r UpdateUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UngroupUsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Errors  *[]interface{}          `json:"errors,omitempty"`
		Help    *map[string]interface{} `json:"help,omitempty"`
		Message *string                 `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r UngroupUsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UngroupUsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GroupUsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Errors  *[]interface{}          `json:"errors,omitempty"`
		Help    *map[string]interface{} `json:"help,omitempty"`
		Message *string                 `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GroupUsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GroupUsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ResetPasswordAdminResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Errors  *[]interface{}          `json:"errors,omitempty"`
		Help    *map[string]interface{} `json:"help,omitempty"`
		Message *string                 `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ResetPasswordAdminResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ResetPasswordAdminResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Errors      *[]interface{}          `json:"errors,omitempty"`
		Help        *map[string]interface{} `json:"help,omitempty"`
		Message     *string                 `json:"message,omitempty"`
		UserDeleted *bool                   `json:"user_deleted,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ValidateLicenseKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Errors  *[]interface{}          `json:"errors,omitempty"`
		Help    *map[string]interface{} `json:"help,omitempty"`
		Message *string                 `json:"message,omitempty"`
	}
	JSON401 *struct {
		Errors *[]struct {
			Message *string `json:"message,omitempty"`
		} `json:"errors,omitempty"`
		Help    *map[string]interface{} `json:"help,omitempty"`
		Message *string                 `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ValidateLicenseKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ValidateLicenseKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CheckPasswordRequirementsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Errors         *[]interface{}          `json:"errors,omitempty"`
		Help           *map[string]interface{} `json:"help,omitempty"`
		Message        *string                 `json:"message,omitempty"`
		PasswordLength *float32                `json:"password_length,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r CheckPasswordRequirementsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CheckPasswordRequirementsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetDefaultBaseImageWithResponse request returning *GetDefaultBaseImageResponse
func (c *ClientWithResponses) GetDefaultBaseImageWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetDefaultBaseImageResponse, error) {
	rsp, err := c.GetDefaultBaseImage(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDefaultBaseImageResponse(rsp)
}

// CheckApiVersionWithResponse request returning *CheckApiVersionResponse
func (c *ClientWithResponses) CheckApiVersionWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*CheckApiVersionResponse, error) {
	rsp, err := c.CheckApiVersion(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCheckApiVersionResponse(rsp)
}

// DeleteLogsWithResponse request returning *DeleteLogsResponse
func (c *ClientWithResponses) DeleteLogsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*DeleteLogsResponse, error) {
	rsp, err := c.DeleteLogs(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteLogsResponse(rsp)
}

// ListLogsWithResponse request returning *ListLogsResponse
func (c *ClientWithResponses) ListLogsWithResponse(ctx context.Context, params *ListLogsParams, reqEditors ...RequestEditorFn) (*ListLogsResponse, error) {
	rsp, err := c.ListLogs(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListLogsResponse(rsp)
}

// CommitChangesToTheBaseImageWithBodyWithResponse request with arbitrary body returning *CommitChangesToTheBaseImageResponse
func (c *ClientWithResponses) CommitChangesToTheBaseImageWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CommitChangesToTheBaseImageResponse, error) {
	rsp, err := c.CommitChangesToTheBaseImageWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCommitChangesToTheBaseImageResponse(rsp)
}

func (c *ClientWithResponses) CommitChangesToTheBaseImageWithResponse(ctx context.Context, body CommitChangesToTheBaseImageJSONRequestBody, reqEditors ...RequestEditorFn) (*CommitChangesToTheBaseImageResponse, error) {
	rsp, err := c.CommitChangesToTheBaseImage(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCommitChangesToTheBaseImageResponse(rsp)
}

// CopyImageWithBodyWithResponse request with arbitrary body returning *CopyImageResponse
func (c *ClientWithResponses) CopyImageWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CopyImageResponse, error) {
	rsp, err := c.CopyImageWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCopyImageResponse(rsp)
}

func (c *ClientWithResponses) CopyImageWithResponse(ctx context.Context, body CopyImageJSONRequestBody, reqEditors ...RequestEditorFn) (*CopyImageResponse, error) {
	rsp, err := c.CopyImage(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCopyImageResponse(rsp)
}

// DeleteImageWithBodyWithResponse request with arbitrary body returning *DeleteImageResponse
func (c *ClientWithResponses) DeleteImageWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteImageResponse, error) {
	rsp, err := c.DeleteImageWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteImageResponse(rsp)
}

func (c *ClientWithResponses) DeleteImageWithResponse(ctx context.Context, body DeleteImageJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteImageResponse, error) {
	rsp, err := c.DeleteImage(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteImageResponse(rsp)
}

// GenerateEmptyStorageWithBodyWithResponse request with arbitrary body returning *GenerateEmptyStorageResponse
func (c *ClientWithResponses) GenerateEmptyStorageWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GenerateEmptyStorageResponse, error) {
	rsp, err := c.GenerateEmptyStorageWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGenerateEmptyStorageResponse(rsp)
}

func (c *ClientWithResponses) GenerateEmptyStorageWithResponse(ctx context.Context, body GenerateEmptyStorageJSONRequestBody, reqEditors ...RequestEditorFn) (*GenerateEmptyStorageResponse, error) {
	rsp, err := c.GenerateEmptyStorage(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGenerateEmptyStorageResponse(rsp)
}

// ListImagesWithResponse request returning *ListImagesResponse
func (c *ClientWithResponses) ListImagesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListImagesResponse, error) {
	rsp, err := c.ListImages(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListImagesResponse(rsp)
}

// ListRemoteImagesWithResponse request returning *ListRemoteImagesResponse
func (c *ClientWithResponses) ListRemoteImagesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListRemoteImagesResponse, error) {
	rsp, err := c.ListRemoteImages(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListRemoteImagesResponse(rsp)
}

// PullImageWithBodyWithResponse request with arbitrary body returning *PullImageResponse
func (c *ClientWithResponses) PullImageWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PullImageResponse, error) {
	rsp, err := c.PullImageWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePullImageResponse(rsp)
}

func (c *ClientWithResponses) PullImageWithResponse(ctx context.Context, body PullImageJSONRequestBody, reqEditors ...RequestEditorFn) (*PullImageResponse, error) {
	rsp, err := c.PullImage(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePullImageResponse(rsp)
}

// RenameImageWithBodyWithResponse request with arbitrary body returning *RenameImageResponse
func (c *ClientWithResponses) RenameImageWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RenameImageResponse, error) {
	rsp, err := c.RenameImageWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRenameImageResponse(rsp)
}

func (c *ClientWithResponses) RenameImageWithResponse(ctx context.Context, body RenameImageJSONRequestBody, reqEditors ...RequestEditorFn) (*RenameImageResponse, error) {
	rsp, err := c.RenameImage(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRenameImageResponse(rsp)
}

// ResizeImageWithBodyWithResponse request with arbitrary body returning *ResizeImageResponse
func (c *ClientWithResponses) ResizeImageWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ResizeImageResponse, error) {
	rsp, err := c.ResizeImageWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseResizeImageResponse(rsp)
}

func (c *ClientWithResponses) ResizeImageWithResponse(ctx context.Context, body ResizeImageJSONRequestBody, reqEditors ...RequestEditorFn) (*ResizeImageResponse, error) {
	rsp, err := c.ResizeImage(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseResizeImageResponse(rsp)
}

// SaveNewBaseImageFromVmWithBodyWithResponse request with arbitrary body returning *SaveNewBaseImageFromVmResponse
func (c *ClientWithResponses) SaveNewBaseImageFromVmWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SaveNewBaseImageFromVmResponse, error) {
	rsp, err := c.SaveNewBaseImageFromVmWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSaveNewBaseImageFromVmResponse(rsp)
}

func (c *ClientWithResponses) SaveNewBaseImageFromVmWithResponse(ctx context.Context, body SaveNewBaseImageFromVmJSONRequestBody, reqEditors ...RequestEditorFn) (*SaveNewBaseImageFromVmResponse, error) {
	rsp, err := c.SaveNewBaseImageFromVm(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSaveNewBaseImageFromVmResponse(rsp)
}

// UploadAnImageWithBodyWithResponse request with arbitrary body returning *UploadAnImageResponse
func (c *ClientWithResponses) UploadAnImageWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UploadAnImageResponse, error) {
	rsp, err := c.UploadAnImageWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUploadAnImageResponse(rsp)
}

// CopyIsoWithBodyWithResponse request with arbitrary body returning *CopyIsoResponse
func (c *ClientWithResponses) CopyIsoWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CopyIsoResponse, error) {
	rsp, err := c.CopyIsoWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCopyIsoResponse(rsp)
}

func (c *ClientWithResponses) CopyIsoWithResponse(ctx context.Context, body CopyIsoJSONRequestBody, reqEditors ...RequestEditorFn) (*CopyIsoResponse, error) {
	rsp, err := c.CopyIso(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCopyIsoResponse(rsp)
}

// DeleteIsoWithBodyWithResponse request with arbitrary body returning *DeleteIsoResponse
func (c *ClientWithResponses) DeleteIsoWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteIsoResponse, error) {
	rsp, err := c.DeleteIsoWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteIsoResponse(rsp)
}

func (c *ClientWithResponses) DeleteIsoWithResponse(ctx context.Context, body DeleteIsoJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteIsoResponse, error) {
	rsp, err := c.DeleteIso(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteIsoResponse(rsp)
}

// ListIsOsInLocalStorageWithResponse request returning *ListIsOsInLocalStorageResponse
func (c *ClientWithResponses) ListIsOsInLocalStorageWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListIsOsInLocalStorageResponse, error) {
	rsp, err := c.ListIsOsInLocalStorage(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListIsOsInLocalStorageResponse(rsp)
}

// ListRemoteIsOsWithResponse request returning *ListRemoteIsOsResponse
func (c *ClientWithResponses) ListRemoteIsOsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListRemoteIsOsResponse, error) {
	rsp, err := c.ListRemoteIsOs(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListRemoteIsOsResponse(rsp)
}

// PullIsoWithBodyWithResponse request with arbitrary body returning *PullIsoResponse
func (c *ClientWithResponses) PullIsoWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PullIsoResponse, error) {
	rsp, err := c.PullIsoWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePullIsoResponse(rsp)
}

func (c *ClientWithResponses) PullIsoWithResponse(ctx context.Context, body PullIsoJSONRequestBody, reqEditors ...RequestEditorFn) (*PullIsoResponse, error) {
	rsp, err := c.PullIso(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePullIsoResponse(rsp)
}

// RenameIsoWithBodyWithResponse request with arbitrary body returning *RenameIsoResponse
func (c *ClientWithResponses) RenameIsoWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RenameIsoResponse, error) {
	rsp, err := c.RenameIsoWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRenameIsoResponse(rsp)
}

func (c *ClientWithResponses) RenameIsoWithResponse(ctx context.Context, body RenameIsoJSONRequestBody, reqEditors ...RequestEditorFn) (*RenameIsoResponse, error) {
	rsp, err := c.RenameIso(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRenameIsoResponse(rsp)
}

// UploadAnIsoWithBodyWithResponse request with arbitrary body returning *UploadAnIsoResponse
func (c *ClientWithResponses) UploadAnIsoWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UploadAnIsoResponse, error) {
	rsp, err := c.UploadAnIsoWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUploadAnIsoResponse(rsp)
}

// DeleteKubeAccountWithBodyWithResponse request with arbitrary body returning *DeleteKubeAccountResponse
func (c *ClientWithResponses) DeleteKubeAccountWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteKubeAccountResponse, error) {
	rsp, err := c.DeleteKubeAccountWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteKubeAccountResponse(rsp)
}

func (c *ClientWithResponses) DeleteKubeAccountWithResponse(ctx context.Context, body DeleteKubeAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteKubeAccountResponse, error) {
	rsp, err := c.DeleteKubeAccount(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteKubeAccountResponse(rsp)
}

// ListKubeAccountsWithBodyWithResponse request with arbitrary body returning *ListKubeAccountsResponse
func (c *ClientWithResponses) ListKubeAccountsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ListKubeAccountsResponse, error) {
	rsp, err := c.ListKubeAccountsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListKubeAccountsResponse(rsp)
}

func (c *ClientWithResponses) ListKubeAccountsWithResponse(ctx context.Context, body ListKubeAccountsJSONRequestBody, reqEditors ...RequestEditorFn) (*ListKubeAccountsResponse, error) {
	rsp, err := c.ListKubeAccounts(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListKubeAccountsResponse(rsp)
}

// CreateKubeAccountWithBodyWithResponse request with arbitrary body returning *CreateKubeAccountResponse
func (c *ClientWithResponses) CreateKubeAccountWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateKubeAccountResponse, error) {
	rsp, err := c.CreateKubeAccountWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateKubeAccountResponse(rsp)
}

func (c *ClientWithResponses) CreateKubeAccountWithResponse(ctx context.Context, body CreateKubeAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateKubeAccountResponse, error) {
	rsp, err := c.CreateKubeAccount(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateKubeAccountResponse(rsp)
}

// DownloadKubeconfigWithBodyWithResponse request with arbitrary body returning *DownloadKubeconfigResponse
func (c *ClientWithResponses) DownloadKubeconfigWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DownloadKubeconfigResponse, error) {
	rsp, err := c.DownloadKubeconfigWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDownloadKubeconfigResponse(rsp)
}

func (c *ClientWithResponses) DownloadKubeconfigWithResponse(ctx context.Context, body DownloadKubeconfigJSONRequestBody, reqEditors ...RequestEditorFn) (*DownloadKubeconfigResponse, error) {
	rsp, err := c.DownloadKubeconfig(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDownloadKubeconfigResponse(rsp)
}

// RegenerateKubeAccountWithBodyWithResponse request with arbitrary body returning *RegenerateKubeAccountResponse
func (c *ClientWithResponses) RegenerateKubeAccountWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RegenerateKubeAccountResponse, error) {
	rsp, err := c.RegenerateKubeAccountWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRegenerateKubeAccountResponse(rsp)
}

func (c *ClientWithResponses) RegenerateKubeAccountWithResponse(ctx context.Context, body RegenerateKubeAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*RegenerateKubeAccountResponse, error) {
	rsp, err := c.RegenerateKubeAccount(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRegenerateKubeAccountResponse(rsp)
}

// RemoveNodeDedicationWithBodyWithResponse request with arbitrary body returning *RemoveNodeDedicationResponse
func (c *ClientWithResponses) RemoveNodeDedicationWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RemoveNodeDedicationResponse, error) {
	rsp, err := c.RemoveNodeDedicationWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveNodeDedicationResponse(rsp)
}

func (c *ClientWithResponses) RemoveNodeDedicationWithResponse(ctx context.Context, body RemoveNodeDedicationJSONRequestBody, reqEditors ...RequestEditorFn) (*RemoveNodeDedicationResponse, error) {
	rsp, err := c.RemoveNodeDedication(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveNodeDedicationResponse(rsp)
}

// DedicateNodeWithBodyWithResponse request with arbitrary body returning *DedicateNodeResponse
func (c *ClientWithResponses) DedicateNodeWithBodyWithResponse(ctx context.Context, userGroup string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DedicateNodeResponse, error) {
	rsp, err := c.DedicateNodeWithBody(ctx, userGroup, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDedicateNodeResponse(rsp)
}

func (c *ClientWithResponses) DedicateNodeWithResponse(ctx context.Context, userGroup string, body DedicateNodeJSONRequestBody, reqEditors ...RequestEditorFn) (*DedicateNodeResponse, error) {
	rsp, err := c.DedicateNode(ctx, userGroup, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDedicateNodeResponse(rsp)
}

// ListAllNodesAdminWithResponse request returning *ListAllNodesAdminResponse
func (c *ClientWithResponses) ListAllNodesAdminWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListAllNodesAdminResponse, error) {
	rsp, err := c.ListAllNodesAdmin(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAllNodesAdminResponse(rsp)
}

// DisableSandboxWithBodyWithResponse request with arbitrary body returning *DisableSandboxResponse
func (c *ClientWithResponses) DisableSandboxWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DisableSandboxResponse, error) {
	rsp, err := c.DisableSandboxWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDisableSandboxResponse(rsp)
}

func (c *ClientWithResponses) DisableSandboxWithResponse(ctx context.Context, body DisableSandboxJSONRequestBody, reqEditors ...RequestEditorFn) (*DisableSandboxResponse, error) {
	rsp, err := c.DisableSandbox(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDisableSandboxResponse(rsp)
}

// EnableSandboxWithBodyWithResponse request with arbitrary body returning *EnableSandboxResponse
func (c *ClientWithResponses) EnableSandboxWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EnableSandboxResponse, error) {
	rsp, err := c.EnableSandboxWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEnableSandboxResponse(rsp)
}

func (c *ClientWithResponses) EnableSandboxWithResponse(ctx context.Context, body EnableSandboxJSONRequestBody, reqEditors ...RequestEditorFn) (*EnableSandboxResponse, error) {
	rsp, err := c.EnableSandbox(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEnableSandboxResponse(rsp)
}

// CheckNodeStatusWithResponse request returning *CheckNodeStatusResponse
func (c *ClientWithResponses) CheckNodeStatusWithResponse(ctx context.Context, node string, reqEditors ...RequestEditorFn) (*CheckNodeStatusResponse, error) {
	rsp, err := c.CheckNodeStatus(ctx, node, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCheckNodeStatusResponse(rsp)
}

// ListPortsWithResponse request returning *ListPortsResponse
func (c *ClientWithResponses) ListPortsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListPortsResponse, error) {
	rsp, err := c.ListPorts(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListPortsResponse(rsp)
}

// AttachDiskWithBodyWithResponse request with arbitrary body returning *AttachDiskResponse
func (c *ClientWithResponses) AttachDiskWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AttachDiskResponse, error) {
	rsp, err := c.AttachDiskWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAttachDiskResponse(rsp)
}

func (c *ClientWithResponses) AttachDiskWithResponse(ctx context.Context, body AttachDiskJSONRequestBody, reqEditors ...RequestEditorFn) (*AttachDiskResponse, error) {
	rsp, err := c.AttachDisk(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAttachDiskResponse(rsp)
}

// CloneVmWithBodyWithResponse request with arbitrary body returning *CloneVmResponse
func (c *ClientWithResponses) CloneVmWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CloneVmResponse, error) {
	rsp, err := c.CloneVmWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCloneVmResponse(rsp)
}

func (c *ClientWithResponses) CloneVmWithResponse(ctx context.Context, body CloneVmJSONRequestBody, reqEditors ...RequestEditorFn) (*CloneVmResponse, error) {
	rsp, err := c.CloneVm(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCloneVmResponse(rsp)
}

// ListYourVmConfigurationsWithBodyWithResponse request with arbitrary body returning *ListYourVmConfigurationsResponse
func (c *ClientWithResponses) ListYourVmConfigurationsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ListYourVmConfigurationsResponse, error) {
	rsp, err := c.ListYourVmConfigurationsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListYourVmConfigurationsResponse(rsp)
}

// SaveVmStateWithBodyWithResponse request with arbitrary body returning *SaveVmStateResponse
func (c *ClientWithResponses) SaveVmStateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SaveVmStateResponse, error) {
	rsp, err := c.SaveVmStateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSaveVmStateResponse(rsp)
}

func (c *ClientWithResponses) SaveVmStateWithResponse(ctx context.Context, body SaveVmStateJSONRequestBody, reqEditors ...RequestEditorFn) (*SaveVmStateResponse, error) {
	rsp, err := c.SaveVmState(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSaveVmStateResponse(rsp)
}

// GetVmConfigurationByNameWithBodyWithResponse request with arbitrary body returning *GetVmConfigurationByNameResponse
func (c *ClientWithResponses) GetVmConfigurationByNameWithBodyWithResponse(ctx context.Context, vm string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetVmConfigurationByNameResponse, error) {
	rsp, err := c.GetVmConfigurationByNameWithBody(ctx, vm, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetVmConfigurationByNameResponse(rsp)
}

// DeleteVmStateWithBodyWithResponse request with arbitrary body returning *DeleteVmStateResponse
func (c *ClientWithResponses) DeleteVmStateWithBodyWithResponse(ctx context.Context, vm string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteVmStateResponse, error) {
	rsp, err := c.DeleteVmStateWithBody(ctx, vm, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteVmStateResponse(rsp)
}

// CreateVmConfigurationWithBodyWithResponse request with arbitrary body returning *CreateVmConfigurationResponse
func (c *ClientWithResponses) CreateVmConfigurationWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateVmConfigurationResponse, error) {
	rsp, err := c.CreateVmConfigurationWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateVmConfigurationResponse(rsp)
}

func (c *ClientWithResponses) CreateVmConfigurationWithResponse(ctx context.Context, body CreateVmConfigurationJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateVmConfigurationResponse, error) {
	rsp, err := c.CreateVmConfiguration(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateVmConfigurationResponse(rsp)
}

// DeleteUserSVmAdminWithBodyWithResponse request with arbitrary body returning *DeleteUserSVmAdminResponse
func (c *ClientWithResponses) DeleteUserSVmAdminWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteUserSVmAdminResponse, error) {
	rsp, err := c.DeleteUserSVmAdminWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteUserSVmAdminResponse(rsp)
}

func (c *ClientWithResponses) DeleteUserSVmAdminWithResponse(ctx context.Context, body DeleteUserSVmAdminJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteUserSVmAdminResponse, error) {
	rsp, err := c.DeleteUserSVmAdmin(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteUserSVmAdminResponse(rsp)
}

// DeployVmConfigurationWithBodyWithResponse request with arbitrary body returning *DeployVmConfigurationResponse
func (c *ClientWithResponses) DeployVmConfigurationWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeployVmConfigurationResponse, error) {
	rsp, err := c.DeployVmConfigurationWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeployVmConfigurationResponse(rsp)
}

func (c *ClientWithResponses) DeployVmConfigurationWithResponse(ctx context.Context, body DeployVmConfigurationJSONRequestBody, reqEditors ...RequestEditorFn) (*DeployVmConfigurationResponse, error) {
	rsp, err := c.DeployVmConfiguration(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeployVmConfigurationResponse(rsp)
}

// ResumeVmWithBodyWithResponse request with arbitrary body returning *ResumeVmResponse
func (c *ClientWithResponses) ResumeVmWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ResumeVmResponse, error) {
	rsp, err := c.ResumeVmWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseResumeVmResponse(rsp)
}

func (c *ClientWithResponses) ResumeVmWithResponse(ctx context.Context, body ResumeVmJSONRequestBody, reqEditors ...RequestEditorFn) (*ResumeVmResponse, error) {
	rsp, err := c.ResumeVm(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseResumeVmResponse(rsp)
}

// RevertVmWithBodyWithResponse request with arbitrary body returning *RevertVmResponse
func (c *ClientWithResponses) RevertVmWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RevertVmResponse, error) {
	rsp, err := c.RevertVmWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRevertVmResponse(rsp)
}

func (c *ClientWithResponses) RevertVmWithResponse(ctx context.Context, body RevertVmJSONRequestBody, reqEditors ...RequestEditorFn) (*RevertVmResponse, error) {
	rsp, err := c.RevertVm(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRevertVmResponse(rsp)
}

// StartVmWithBodyWithResponse request with arbitrary body returning *StartVmResponse
func (c *ClientWithResponses) StartVmWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StartVmResponse, error) {
	rsp, err := c.StartVmWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStartVmResponse(rsp)
}

func (c *ClientWithResponses) StartVmWithResponse(ctx context.Context, body StartVmJSONRequestBody, reqEditors ...RequestEditorFn) (*StartVmResponse, error) {
	rsp, err := c.StartVm(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStartVmResponse(rsp)
}

// StopVmWithBodyWithResponse request with arbitrary body returning *StopVmResponse
func (c *ClientWithResponses) StopVmWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StopVmResponse, error) {
	rsp, err := c.StopVmWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStopVmResponse(rsp)
}

func (c *ClientWithResponses) StopVmWithResponse(ctx context.Context, body StopVmJSONRequestBody, reqEditors ...RequestEditorFn) (*StopVmResponse, error) {
	rsp, err := c.StopVm(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStopVmResponse(rsp)
}

// SuspendVmWithBodyWithResponse request with arbitrary body returning *SuspendVmResponse
func (c *ClientWithResponses) SuspendVmWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SuspendVmResponse, error) {
	rsp, err := c.SuspendVmWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSuspendVmResponse(rsp)
}

func (c *ClientWithResponses) SuspendVmWithResponse(ctx context.Context, body SuspendVmJSONRequestBody, reqEditors ...RequestEditorFn) (*SuspendVmResponse, error) {
	rsp, err := c.SuspendVm(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSuspendVmResponse(rsp)
}

// ListYourVMsWithResponse request returning *ListYourVMsResponse
func (c *ClientWithResponses) ListYourVMsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListYourVMsResponse, error) {
	rsp, err := c.ListYourVMs(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListYourVMsResponse(rsp)
}

// ListDisksWithBodyWithResponse request with arbitrary body returning *ListDisksResponse
func (c *ClientWithResponses) ListDisksWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ListDisksResponse, error) {
	rsp, err := c.ListDisksWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListDisksResponse(rsp)
}

func (c *ClientWithResponses) ListDisksWithResponse(ctx context.Context, body ListDisksJSONRequestBody, reqEditors ...RequestEditorFn) (*ListDisksResponse, error) {
	rsp, err := c.ListDisks(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListDisksResponse(rsp)
}

// ListAllVMsAdminWithResponse request returning *ListAllVMsAdminResponse
func (c *ClientWithResponses) ListAllVMsAdminWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListAllVMsAdminResponse, error) {
	rsp, err := c.ListAllVMsAdmin(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAllVMsAdminResponse(rsp)
}

// ListUserSVMsAdminWithResponse request returning *ListUserSVMsAdminResponse
func (c *ClientWithResponses) ListUserSVMsAdminWithResponse(ctx context.Context, email string, reqEditors ...RequestEditorFn) (*ListUserSVMsAdminResponse, error) {
	rsp, err := c.ListUserSVMsAdmin(ctx, email, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListUserSVMsAdminResponse(rsp)
}

// MigrateVmWithBodyWithResponse request with arbitrary body returning *MigrateVmResponse
func (c *ClientWithResponses) MigrateVmWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MigrateVmResponse, error) {
	rsp, err := c.MigrateVmWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMigrateVmResponse(rsp)
}

func (c *ClientWithResponses) MigrateVmWithResponse(ctx context.Context, body MigrateVmJSONRequestBody, reqEditors ...RequestEditorFn) (*MigrateVmResponse, error) {
	rsp, err := c.MigrateVm(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMigrateVmResponse(rsp)
}

// PurgeUserSVMsAdminWithBodyWithResponse request with arbitrary body returning *PurgeUserSVMsAdminResponse
func (c *ClientWithResponses) PurgeUserSVMsAdminWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PurgeUserSVMsAdminResponse, error) {
	rsp, err := c.PurgeUserSVMsAdminWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePurgeUserSVMsAdminResponse(rsp)
}

func (c *ClientWithResponses) PurgeUserSVMsAdminWithResponse(ctx context.Context, body PurgeUserSVMsAdminJSONRequestBody, reqEditors ...RequestEditorFn) (*PurgeUserSVMsAdminResponse, error) {
	rsp, err := c.PurgeUserSVMsAdmin(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePurgeUserSVMsAdminResponse(rsp)
}

// UnScaleVmWithBodyWithResponse request with arbitrary body returning *UnScaleVmResponse
func (c *ClientWithResponses) UnScaleVmWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UnScaleVmResponse, error) {
	rsp, err := c.UnScaleVmWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnScaleVmResponse(rsp)
}

func (c *ClientWithResponses) UnScaleVmWithResponse(ctx context.Context, body UnScaleVmJSONRequestBody, reqEditors ...RequestEditorFn) (*UnScaleVmResponse, error) {
	rsp, err := c.UnScaleVm(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnScaleVmResponse(rsp)
}

// CheckUserSVmStatusAdminWithResponse request returning *CheckUserSVmStatusAdminResponse
func (c *ClientWithResponses) CheckUserSVmStatusAdminWithResponse(ctx context.Context, vm string, reqEditors ...RequestEditorFn) (*CheckUserSVmStatusAdminResponse, error) {
	rsp, err := c.CheckUserSVmStatusAdmin(ctx, vm, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCheckUserSVmStatusAdminResponse(rsp)
}

// RevokeTokenWithResponse request returning *RevokeTokenResponse
func (c *ClientWithResponses) RevokeTokenWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*RevokeTokenResponse, error) {
	rsp, err := c.RevokeToken(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRevokeTokenResponse(rsp)
}

// CheckTokenStatusWithResponse request returning *CheckTokenStatusResponse
func (c *ClientWithResponses) CheckTokenStatusWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*CheckTokenStatusResponse, error) {
	rsp, err := c.CheckTokenStatus(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCheckTokenStatusResponse(rsp)
}

// CreateTokenWithBodyWithResponse request with arbitrary body returning *CreateTokenResponse
func (c *ClientWithResponses) CreateTokenWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTokenResponse, error) {
	rsp, err := c.CreateTokenWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTokenResponse(rsp)
}

func (c *ClientWithResponses) CreateTokenWithResponse(ctx context.Context, body CreateTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTokenResponse, error) {
	rsp, err := c.CreateToken(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTokenResponse(rsp)
}

// GetUsersWithResponse request returning *GetUsersResponse
func (c *ClientWithResponses) GetUsersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetUsersResponse, error) {
	rsp, err := c.GetUsers(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUsersResponse(rsp)
}

// CreateUserWithBodyWithResponse request with arbitrary body returning *CreateUserResponse
func (c *ClientWithResponses) CreateUserWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateUserResponse, error) {
	rsp, err := c.CreateUserWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateUserResponse(rsp)
}

func (c *ClientWithResponses) CreateUserWithResponse(ctx context.Context, body CreateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateUserResponse, error) {
	rsp, err := c.CreateUser(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateUserResponse(rsp)
}

// UpdateUserWithBodyWithResponse request with arbitrary body returning *UpdateUserResponse
func (c *ClientWithResponses) UpdateUserWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateUserResponse, error) {
	rsp, err := c.UpdateUserWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateUserResponse(rsp)
}

func (c *ClientWithResponses) UpdateUserWithResponse(ctx context.Context, body UpdateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateUserResponse, error) {
	rsp, err := c.UpdateUser(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateUserResponse(rsp)
}

// UngroupUsersWithBodyWithResponse request with arbitrary body returning *UngroupUsersResponse
func (c *ClientWithResponses) UngroupUsersWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UngroupUsersResponse, error) {
	rsp, err := c.UngroupUsersWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUngroupUsersResponse(rsp)
}

func (c *ClientWithResponses) UngroupUsersWithResponse(ctx context.Context, body UngroupUsersJSONRequestBody, reqEditors ...RequestEditorFn) (*UngroupUsersResponse, error) {
	rsp, err := c.UngroupUsers(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUngroupUsersResponse(rsp)
}

// GroupUsersWithBodyWithResponse request with arbitrary body returning *GroupUsersResponse
func (c *ClientWithResponses) GroupUsersWithBodyWithResponse(ctx context.Context, userGroup string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GroupUsersResponse, error) {
	rsp, err := c.GroupUsersWithBody(ctx, userGroup, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGroupUsersResponse(rsp)
}

func (c *ClientWithResponses) GroupUsersWithResponse(ctx context.Context, userGroup string, body GroupUsersJSONRequestBody, reqEditors ...RequestEditorFn) (*GroupUsersResponse, error) {
	rsp, err := c.GroupUsers(ctx, userGroup, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGroupUsersResponse(rsp)
}

// ResetPasswordAdminWithBodyWithResponse request with arbitrary body returning *ResetPasswordAdminResponse
func (c *ClientWithResponses) ResetPasswordAdminWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ResetPasswordAdminResponse, error) {
	rsp, err := c.ResetPasswordAdminWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseResetPasswordAdminResponse(rsp)
}

func (c *ClientWithResponses) ResetPasswordAdminWithResponse(ctx context.Context, body ResetPasswordAdminJSONRequestBody, reqEditors ...RequestEditorFn) (*ResetPasswordAdminResponse, error) {
	rsp, err := c.ResetPasswordAdmin(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseResetPasswordAdminResponse(rsp)
}

// DeleteUserWithResponse request returning *DeleteUserResponse
func (c *ClientWithResponses) DeleteUserWithResponse(ctx context.Context, email string, reqEditors ...RequestEditorFn) (*DeleteUserResponse, error) {
	rsp, err := c.DeleteUser(ctx, email, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteUserResponse(rsp)
}

// ValidateLicenseKeyWithBodyWithResponse request with arbitrary body returning *ValidateLicenseKeyResponse
func (c *ClientWithResponses) ValidateLicenseKeyWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ValidateLicenseKeyResponse, error) {
	rsp, err := c.ValidateLicenseKeyWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseValidateLicenseKeyResponse(rsp)
}

func (c *ClientWithResponses) ValidateLicenseKeyWithResponse(ctx context.Context, body ValidateLicenseKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*ValidateLicenseKeyResponse, error) {
	rsp, err := c.ValidateLicenseKey(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseValidateLicenseKeyResponse(rsp)
}

// CheckPasswordRequirementsWithResponse request returning *CheckPasswordRequirementsResponse
func (c *ClientWithResponses) CheckPasswordRequirementsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*CheckPasswordRequirementsResponse, error) {
	rsp, err := c.CheckPasswordRequirements(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCheckPasswordRequirementsResponse(rsp)
}

// ParseGetDefaultBaseImageResponse parses an HTTP response from a GetDefaultBaseImageWithResponse call
func ParseGetDefaultBaseImageResponse(rsp *http.Response) (*GetDefaultBaseImageResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDefaultBaseImageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			DefaultBaseImage *string                 `json:"default_base_image,omitempty"`
			Errors           *[]interface{}          `json:"errors,omitempty"`
			Help             *map[string]interface{} `json:"help,omitempty"`
			Message          *string                 `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCheckApiVersionResponse parses an HTTP response from a CheckApiVersionWithResponse call
func ParseCheckApiVersionResponse(rsp *http.Response) (*CheckApiVersionResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CheckApiVersionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			ApiVersion *string                 `json:"api_version,omitempty"`
			Errors     *[]interface{}          `json:"errors,omitempty"`
			Help       *map[string]interface{} `json:"help,omitempty"`
			Message    *string                 `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteLogsResponse parses an HTTP response from a DeleteLogsWithResponse call
func ParseDeleteLogsResponse(rsp *http.Response) (*DeleteLogsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteLogsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Errors  *[]interface{}          `json:"errors,omitempty"`
			Help    *map[string]interface{} `json:"help,omitempty"`
			Message *string                 `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListLogsResponse parses an HTTP response from a ListLogsWithResponse call
func ParseListLogsResponse(rsp *http.Response) (*ListLogsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListLogsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Errors *[]interface{}          `json:"errors,omitempty"`
			Help   *map[string]interface{} `json:"help,omitempty"`
			Logs   *[]struct {
				CreatedAt  *string `json:"createdAt,omitempty"`
				Id         *string `json:"id,omitempty"`
				LogVersion *string `json:"logVersion,omitempty"`
				Request    *struct {
					Body    *map[string]interface{} `json:"body,omitempty"`
					Headers *struct {
						Accept           *string `json:"accept,omitempty"`
						AcceptEncoding   *string `json:"accept-encoding,omitempty"`
						Connection       *string `json:"connection,omitempty"`
						ContentLength    *string `json:"content-length,omitempty"`
						ContentType      *string `json:"content-type,omitempty"`
						Host             *string `json:"host,omitempty"`
						Platform         *string `json:"platform,omitempty"`
						Release          *string `json:"release,omitempty"`
						UserAgent        *string `json:"user-agent,omitempty"`
						XCliVersion      *string `json:"x-cli-version,omitempty"`
						XForwardedFor    *string `json:"x-forwarded-for,omitempty"`
						XForwardedHost   *string `json:"x-forwarded-host,omitempty"`
						XForwardedPort   *string `json:"x-forwarded-port,omitempty"`
						XForwardedProto  *string `json:"x-forwarded-proto,omitempty"`
						XForwardedServer *string `json:"x-forwarded-server,omitempty"`
						XRealIp          *string `json:"x-real-ip,omitempty"`
					} `json:"headers,omitempty"`
					Method *string `json:"method,omitempty"`
					Url    *string `json:"url,omitempty"`
				} `json:"request,omitempty"`
				Response *struct {
					Body *struct {
						ApiVersion    *string `json:"api_version,omitempty"`
						Authenticated *bool   `json:"authenticated,omitempty"`
						Configs       *[]struct {
							AttachedDisk   *string  `json:"attached_disk,omitempty"`
							GpuPassthrough *bool    `json:"gpu_passthrough,omitempty"`
							IoBoost        *bool    `json:"io_boost,omitempty"`
							IsoImage       *string  `json:"iso_image,omitempty"`
							OrkaBaseImage  *string  `json:"orka_base_image,omitempty"`
							OrkaCpuCore    *float32 `json:"orka_cpu_core,omitempty"`
							OrkaVmName     *string  `json:"orka_vm_name,omitempty"`
							Owner          *string  `json:"owner,omitempty"`
							UseSavedState  *bool    `json:"use_saved_state,omitempty"`
							VcpuCount      *float32 `json:"vcpu_count,omitempty"`
							VncConsole     *bool    `json:"vnc_console,omitempty"`
						} `json:"configs,omitempty"`
						Email                         *string                 `json:"email,omitempty"`
						Errors                        *[]interface{}          `json:"errors,omitempty"`
						FailedVirtualMachineResources *[]interface{}          `json:"failed_virtual_machine_resources,omitempty"`
						Help                          *map[string]interface{} `json:"help,omitempty"`
						IsTokenRevoked                *bool                   `json:"is_token_revoked,omitempty"`
						Message                       *string                 `json:"message,omitempty"`
						VirtualMachineResources       *[]struct {
							BaseImage             *string  `json:"base_image,omitempty"`
							ConfigurationTemplate *string  `json:"configuration_template,omitempty"`
							Cpu                   *float32 `json:"cpu,omitempty"`
							GpuPassthrough        *bool    `json:"gpu_passthrough,omitempty"`
							Image                 *string  `json:"image,omitempty"`
							IoBoost               *bool    `json:"io_boost,omitempty"`
							Owner                 *string  `json:"owner,omitempty"`
							UseSavedState         *bool    `json:"use_saved_state,omitempty"`
							Vcpu                  *float32 `json:"vcpu,omitempty"`
							VirtualMachineName    *string  `json:"virtual_machine_name,omitempty"`
							VmDeploymentStatus    *string  `json:"vm_deployment_status,omitempty"`
						} `json:"virtual_machine_resources,omitempty"`
					} `json:"body,omitempty"`
					Headers *struct {
						AccessControlAllowOrigin *string      `json:"access-control-allow-origin,omitempty"`
						ContentLength            *interface{} `json:"content-length,omitempty"`
						ContentSecurityPolicy    *string      `json:"content-security-policy,omitempty"`
						ContentType              *string      `json:"content-type,omitempty"`
						Etag                     *string      `json:"etag,omitempty"`
						XContentTypeOptions      *string      `json:"x-content-type-options,omitempty"`
					} `json:"headers,omitempty"`
					StatusCode *float32 `json:"statusCode,omitempty"`
				} `json:"response,omitempty"`
				User *struct {
					Email *string `json:"email,omitempty"`
					Id    *string `json:"id,omitempty"`
				} `json:"user,omitempty"`
			} `json:"logs,omitempty"`
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCommitChangesToTheBaseImageResponse parses an HTTP response from a CommitChangesToTheBaseImageWithResponse call
func ParseCommitChangesToTheBaseImageResponse(rsp *http.Response) (*CommitChangesToTheBaseImageResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CommitChangesToTheBaseImageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Errors  *[]interface{}          `json:"errors,omitempty"`
			Help    *map[string]interface{} `json:"help,omitempty"`
			Message *string                 `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCopyImageResponse parses an HTTP response from a CopyImageWithResponse call
func ParseCopyImageResponse(rsp *http.Response) (*CopyImageResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CopyImageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Errors  *[]interface{}          `json:"errors,omitempty"`
			Help    *map[string]interface{} `json:"help,omitempty"`
			Message *string                 `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteImageResponse parses an HTTP response from a DeleteImageWithResponse call
func ParseDeleteImageResponse(rsp *http.Response) (*DeleteImageResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteImageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Errors  *[]interface{}          `json:"errors,omitempty"`
			Help    *map[string]interface{} `json:"help,omitempty"`
			Message *string                 `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGenerateEmptyStorageResponse parses an HTTP response from a GenerateEmptyStorageWithResponse call
func ParseGenerateEmptyStorageResponse(rsp *http.Response) (*GenerateEmptyStorageResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GenerateEmptyStorageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Errors  *[]interface{}          `json:"errors,omitempty"`
			Help    *map[string]interface{} `json:"help,omitempty"`
			Message *string                 `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListImagesResponse parses an HTTP response from a ListImagesWithResponse call
func ParseListImagesResponse(rsp *http.Response) (*ListImagesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListImagesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Errors          *[]interface{}          `json:"errors,omitempty"`
			Help            *map[string]interface{} `json:"help,omitempty"`
			ImageAttributes *[]struct {
				DateAdded *string `json:"date_added,omitempty"`
				Image     *string `json:"image,omitempty"`
				ImageSize *string `json:"image_size,omitempty"`
				Modified  *string `json:"modified,omitempty"`
				Owner     *string `json:"owner,omitempty"`
			} `json:"image_attributes,omitempty"`
			Images  *[]string `json:"images,omitempty"`
			Message *string   `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListRemoteImagesResponse parses an HTTP response from a ListRemoteImagesWithResponse call
func ParseListRemoteImagesResponse(rsp *http.Response) (*ListRemoteImagesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListRemoteImagesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Errors  *[]interface{}          `json:"errors,omitempty"`
			Help    *map[string]interface{} `json:"help,omitempty"`
			Images  *[]string               `json:"images,omitempty"`
			Message *string                 `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePullImageResponse parses an HTTP response from a PullImageWithResponse call
func ParsePullImageResponse(rsp *http.Response) (*PullImageResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PullImageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Errors  *[]interface{}          `json:"errors,omitempty"`
			Help    *map[string]interface{} `json:"help,omitempty"`
			Message *string                 `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseRenameImageResponse parses an HTTP response from a RenameImageWithResponse call
func ParseRenameImageResponse(rsp *http.Response) (*RenameImageResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RenameImageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Errors  *[]interface{}          `json:"errors,omitempty"`
			Help    *map[string]interface{} `json:"help,omitempty"`
			Message *string                 `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseResizeImageResponse parses an HTTP response from a ResizeImageWithResponse call
func ParseResizeImageResponse(rsp *http.Response) (*ResizeImageResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ResizeImageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Errors *[]interface{}          `json:"errors,omitempty"`
			Help   *map[string]interface{} `json:"help,omitempty"`
			Logs   *[]struct {
				Channel *string `json:"channel,omitempty"`
				Message *string `json:"message,omitempty"`
			} `json:"logs,omitempty"`
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSaveNewBaseImageFromVmResponse parses an HTTP response from a SaveNewBaseImageFromVmWithResponse call
func ParseSaveNewBaseImageFromVmResponse(rsp *http.Response) (*SaveNewBaseImageFromVmResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SaveNewBaseImageFromVmResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Errors  *[]interface{}          `json:"errors,omitempty"`
			Help    *map[string]interface{} `json:"help,omitempty"`
			Message *string                 `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUploadAnImageResponse parses an HTTP response from a UploadAnImageWithResponse call
func ParseUploadAnImageResponse(rsp *http.Response) (*UploadAnImageResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UploadAnImageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Errors  *[]interface{}          `json:"errors,omitempty"`
			Help    *map[string]interface{} `json:"help,omitempty"`
			Message *string                 `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCopyIsoResponse parses an HTTP response from a CopyIsoWithResponse call
func ParseCopyIsoResponse(rsp *http.Response) (*CopyIsoResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CopyIsoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Errors  *[]interface{}          `json:"errors,omitempty"`
			Help    *map[string]interface{} `json:"help,omitempty"`
			Message *string                 `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteIsoResponse parses an HTTP response from a DeleteIsoWithResponse call
func ParseDeleteIsoResponse(rsp *http.Response) (*DeleteIsoResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteIsoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Errors  *[]interface{}          `json:"errors,omitempty"`
			Help    *map[string]interface{} `json:"help,omitempty"`
			Message *string                 `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListIsOsInLocalStorageResponse parses an HTTP response from a ListIsOsInLocalStorageWithResponse call
func ParseListIsOsInLocalStorageResponse(rsp *http.Response) (*ListIsOsInLocalStorageResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListIsOsInLocalStorageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Errors        *[]interface{}          `json:"errors,omitempty"`
			Help          *map[string]interface{} `json:"help,omitempty"`
			IsoAttributes *[]struct {
				Iso      *string `json:"iso,omitempty"`
				IsoSize  *string `json:"iso_size,omitempty"`
				Modified *string `json:"modified,omitempty"`
			} `json:"iso_attributes,omitempty"`
			Isos    *[]string `json:"isos,omitempty"`
			Message *string   `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListRemoteIsOsResponse parses an HTTP response from a ListRemoteIsOsWithResponse call
func ParseListRemoteIsOsResponse(rsp *http.Response) (*ListRemoteIsOsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListRemoteIsOsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Errors  *[]interface{}          `json:"errors,omitempty"`
			Help    *map[string]interface{} `json:"help,omitempty"`
			Isos    *[]string               `json:"isos,omitempty"`
			Message *string                 `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePullIsoResponse parses an HTTP response from a PullIsoWithResponse call
func ParsePullIsoResponse(rsp *http.Response) (*PullIsoResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PullIsoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Errors  *[]interface{}          `json:"errors,omitempty"`
			Help    *map[string]interface{} `json:"help,omitempty"`
			Message *string                 `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseRenameIsoResponse parses an HTTP response from a RenameIsoWithResponse call
func ParseRenameIsoResponse(rsp *http.Response) (*RenameIsoResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RenameIsoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Errors  *[]interface{}          `json:"errors,omitempty"`
			Help    *map[string]interface{} `json:"help,omitempty"`
			Message *string                 `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUploadAnIsoResponse parses an HTTP response from a UploadAnIsoWithResponse call
func ParseUploadAnIsoResponse(rsp *http.Response) (*UploadAnIsoResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UploadAnIsoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Errors  *[]interface{}          `json:"errors,omitempty"`
			Help    *map[string]interface{} `json:"help,omitempty"`
			Message *string                 `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteKubeAccountResponse parses an HTTP response from a DeleteKubeAccountWithResponse call
func ParseDeleteKubeAccountResponse(rsp *http.Response) (*DeleteKubeAccountResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteKubeAccountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Errors  *[]interface{}          `json:"errors,omitempty"`
			Help    *map[string]interface{} `json:"help,omitempty"`
			Message *string                 `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListKubeAccountsResponse parses an HTTP response from a ListKubeAccountsWithResponse call
func ParseListKubeAccountsResponse(rsp *http.Response) (*ListKubeAccountsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListKubeAccountsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Errors          *[]interface{}          `json:"errors,omitempty"`
			Help            *map[string]interface{} `json:"help,omitempty"`
			Message         *string                 `json:"message,omitempty"`
			ServiceAccounts *[]string               `json:"serviceAccounts,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateKubeAccountResponse parses an HTTP response from a CreateKubeAccountWithResponse call
func ParseCreateKubeAccountResponse(rsp *http.Response) (*CreateKubeAccountResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateKubeAccountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Errors     *[]interface{}          `json:"errors,omitempty"`
			Help       *map[string]interface{} `json:"help,omitempty"`
			Kubeconfig *string                 `json:"kubeconfig,omitempty"`
			Message    *string                 `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDownloadKubeconfigResponse parses an HTTP response from a DownloadKubeconfigWithResponse call
func ParseDownloadKubeconfigResponse(rsp *http.Response) (*DownloadKubeconfigResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DownloadKubeconfigResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Errors     *[]interface{}          `json:"errors,omitempty"`
			Help       *map[string]interface{} `json:"help,omitempty"`
			Kubeconfig *string                 `json:"kubeconfig,omitempty"`
			Message    *string                 `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseRegenerateKubeAccountResponse parses an HTTP response from a RegenerateKubeAccountWithResponse call
func ParseRegenerateKubeAccountResponse(rsp *http.Response) (*RegenerateKubeAccountResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RegenerateKubeAccountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Errors     *[]interface{}          `json:"errors,omitempty"`
			Help       *map[string]interface{} `json:"help,omitempty"`
			Kubeconfig *string                 `json:"kubeconfig,omitempty"`
			Message    *string                 `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseRemoveNodeDedicationResponse parses an HTTP response from a RemoveNodeDedicationWithResponse call
func ParseRemoveNodeDedicationResponse(rsp *http.Response) (*RemoveNodeDedicationResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveNodeDedicationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Details *[]struct {
				Detail *string `json:"detail,omitempty"`
				Node   *string `json:"node,omitempty"`
			} `json:"details,omitempty"`
			Errors  *[]interface{}          `json:"errors,omitempty"`
			Help    *map[string]interface{} `json:"help,omitempty"`
			Message *string                 `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDedicateNodeResponse parses an HTTP response from a DedicateNodeWithResponse call
func ParseDedicateNodeResponse(rsp *http.Response) (*DedicateNodeResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DedicateNodeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Details *[]struct {
				Detail *string `json:"detail,omitempty"`
				Node   *string `json:"node,omitempty"`
			} `json:"details,omitempty"`
			Errors  *[]interface{}          `json:"errors,omitempty"`
			Help    *map[string]interface{} `json:"help,omitempty"`
			Message *string                 `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListAllNodesAdminResponse parses an HTTP response from a ListAllNodesAdminWithResponse call
func ParseListAllNodesAdminResponse(rsp *http.Response) (*ListAllNodesAdminResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAllNodesAdminResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDisableSandboxResponse parses an HTTP response from a DisableSandboxWithResponse call
func ParseDisableSandboxResponse(rsp *http.Response) (*DisableSandboxResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DisableSandboxResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Errors  *[]interface{}          `json:"errors,omitempty"`
			Help    *map[string]interface{} `json:"help,omitempty"`
			Message *string                 `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseEnableSandboxResponse parses an HTTP response from a EnableSandboxWithResponse call
func ParseEnableSandboxResponse(rsp *http.Response) (*EnableSandboxResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EnableSandboxResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Errors  *[]interface{}          `json:"errors,omitempty"`
			Help    *map[string]interface{} `json:"help,omitempty"`
			Message *string                 `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCheckNodeStatusResponse parses an HTTP response from a CheckNodeStatusWithResponse call
func ParseCheckNodeStatusResponse(rsp *http.Response) (*CheckNodeStatusResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CheckNodeStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Errors     *[]interface{}          `json:"errors,omitempty"`
			Help       *map[string]interface{} `json:"help,omitempty"`
			Message    *string                 `json:"message,omitempty"`
			NodeStatus *struct {
				Cpu      *float32 `json:"cpu,omitempty"`
				Memory   *string  `json:"memory,omitempty"`
				NodeName *string  `json:"nodeName,omitempty"`
				Sandbox  *string  `json:"sandbox,omitempty"`
				Status   *string  `json:"status,omitempty"`
			} `json:"node_status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListPortsResponse parses an HTTP response from a ListPortsWithResponse call
func ParseListPortsResponse(rsp *http.Response) (*ListPortsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListPortsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Errors        *[]interface{}          `json:"errors,omitempty"`
			Help          *map[string]interface{} `json:"help,omitempty"`
			Message       *string                 `json:"message,omitempty"`
			ReservedPorts *[]struct {
				GuestPort    *float32 `json:"guest_port,omitempty"`
				HostPort     *float32 `json:"host_port,omitempty"`
				OrkaNodeName *string  `json:"orka_node_name,omitempty"`
				Protocol     *string  `json:"protocol,omitempty"`
			} `json:"reserved_ports,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAttachDiskResponse parses an HTTP response from a AttachDiskWithResponse call
func ParseAttachDiskResponse(rsp *http.Response) (*AttachDiskResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AttachDiskResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			DeployVirtualMachine *string                 `json:"deploy_virtual_machine,omitempty"`
			Errors               *[]interface{}          `json:"errors,omitempty"`
			Help                 *map[string]interface{} `json:"help,omitempty"`
			Message              *string                 `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCloneVmResponse parses an HTTP response from a CloneVmWithResponse call
func ParseCloneVmResponse(rsp *http.Response) (*CloneVmResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CloneVmResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Errors       *[]interface{}          `json:"errors,omitempty"`
			Help         *map[string]interface{} `json:"help,omitempty"`
			Message      *string                 `json:"message,omitempty"`
			PortWarnings *[]interface{}          `json:"port_warnings,omitempty"`
			VmId         *string                 `json:"vm_id,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListYourVmConfigurationsResponse parses an HTTP response from a ListYourVmConfigurationsWithResponse call
func ParseListYourVmConfigurationsResponse(rsp *http.Response) (*ListYourVmConfigurationsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListYourVmConfigurationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Configs *[]struct {
				AttachedDisk   *string  `json:"attached_disk,omitempty"`
				GpuPassthrough *bool    `json:"gpu_passthrough,omitempty"`
				IoBoost        *bool    `json:"io_boost,omitempty"`
				IsoImage       *string  `json:"iso_image,omitempty"`
				OrkaBaseImage  *string  `json:"orka_base_image,omitempty"`
				OrkaCpuCore    *float32 `json:"orka_cpu_core,omitempty"`
				OrkaVmName     *string  `json:"orka_vm_name,omitempty"`
				Owner          *string  `json:"owner,omitempty"`
				UseSavedState  *bool    `json:"use_saved_state,omitempty"`
				VcpuCount      *float32 `json:"vcpu_count,omitempty"`
				VncConsole     *bool    `json:"vnc_console,omitempty"`
			} `json:"configs,omitempty"`
			Errors  *[]interface{}          `json:"errors,omitempty"`
			Help    *map[string]interface{} `json:"help,omitempty"`
			Message *string                 `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSaveVmStateResponse parses an HTTP response from a SaveVmStateWithResponse call
func ParseSaveVmStateResponse(rsp *http.Response) (*SaveVmStateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SaveVmStateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Errors *[]interface{} `json:"errors,omitempty"`
			Help   *struct {
				Info *string `json:"info,omitempty"`
			} `json:"help,omitempty"`
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetVmConfigurationByNameResponse parses an HTTP response from a GetVmConfigurationByNameWithResponse call
func ParseGetVmConfigurationByNameResponse(rsp *http.Response) (*GetVmConfigurationByNameResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetVmConfigurationByNameResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Configs *[]struct {
				AttachedDisk   *string  `json:"attached_disk,omitempty"`
				GpuPassthrough *bool    `json:"gpu_passthrough,omitempty"`
				IoBoost        *bool    `json:"io_boost,omitempty"`
				IsoImage       *string  `json:"iso_image,omitempty"`
				OrkaBaseImage  *string  `json:"orka_base_image,omitempty"`
				OrkaCpuCore    *float32 `json:"orka_cpu_core,omitempty"`
				OrkaVmName     *string  `json:"orka_vm_name,omitempty"`
				Owner          *string  `json:"owner,omitempty"`
				UseSavedState  *bool    `json:"use_saved_state,omitempty"`
				VncConsole     *bool    `json:"vnc_console,omitempty"`
			} `json:"configs,omitempty"`
			Errors  *[]interface{}          `json:"errors,omitempty"`
			Help    *map[string]interface{} `json:"help,omitempty"`
			Message *string                 `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteVmStateResponse parses an HTTP response from a DeleteVmStateWithResponse call
func ParseDeleteVmStateResponse(rsp *http.Response) (*DeleteVmStateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteVmStateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Errors *[]interface{} `json:"errors,omitempty"`
			Help   *struct {
				Info *string `json:"info,omitempty"`
			} `json:"help,omitempty"`
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateVmConfigurationResponse parses an HTTP response from a CreateVmConfigurationWithResponse call
func ParseCreateVmConfigurationResponse(rsp *http.Response) (*CreateVmConfigurationResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateVmConfigurationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			Errors *[]interface{} `json:"errors,omitempty"`
			Help   *struct {
				DeployVirtualMachine         *string `json:"deploy_virtual_machine,omitempty"`
				RequiredRequestDataForDeploy *struct {
					OrkaNodeName *string `json:"orka_node_name,omitempty"`
					OrkaVmName   *string `json:"orka_vm_name,omitempty"`
				} `json:"required_request_data_for_deploy,omitempty"`
			} `json:"help,omitempty"`
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseDeleteUserSVmAdminResponse parses an HTTP response from a DeleteUserSVmAdminWithResponse call
func ParseDeleteUserSVmAdminResponse(rsp *http.Response) (*DeleteUserSVmAdminResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteUserSVmAdminResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Errors *[]interface{} `json:"errors,omitempty"`
			Help   *struct {
				DeployVirtualMachine         *string `json:"deploy_virtual_machine,omitempty"`
				ListOrkaNodes                *string `json:"list_orka_nodes,omitempty"`
				RequiredRequestDataForDeploy *struct {
					OrkaVmName *string `json:"orka_vm_name,omitempty"`
				} `json:"required_request_data_for_deploy,omitempty"`
			} `json:"help,omitempty"`
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeployVmConfigurationResponse parses an HTTP response from a DeployVmConfigurationWithResponse call
func ParseDeployVmConfigurationResponse(rsp *http.Response) (*DeployVmConfigurationResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeployVmConfigurationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Errors *[]interface{} `json:"errors,omitempty"`
			Help   *struct {
				DataForVirtualMachineExecTasks *struct {
					OrkaVmName *string `json:"orka_vm_name,omitempty"`
				} `json:"data_for_virtual_machine_exec_tasks,omitempty"`
				ResumeVirtualMachine  *string `json:"resume_virtual_machine,omitempty"`
				StartVirtualMachine   *string `json:"start_virtual_machine,omitempty"`
				StopVirtualMachine    *string `json:"stop_virtual_machine,omitempty"`
				SuspendVirtualMachine *string `json:"suspend_virtual_machine,omitempty"`
				VirtualMachineVnc     *string `json:"virtual_machine_vnc,omitempty"`
			} `json:"help,omitempty"`
			HostCpu         *string        `json:"host_cpu,omitempty"`
			Ip              *string        `json:"ip,omitempty"`
			Message         *string        `json:"message,omitempty"`
			PortWarnings    *[]interface{} `json:"port_warnings,omitempty"`
			Ram             *string        `json:"ram,omitempty"`
			ScreenSharePort *string        `json:"screen_share_port,omitempty"`
			SshPort         *string        `json:"ssh_port,omitempty"`
			Vcpu            *string        `json:"vcpu,omitempty"`
			VmId            *string        `json:"vm_id,omitempty"`
			VncPort         *string        `json:"vnc_port,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseResumeVmResponse parses an HTTP response from a ResumeVmWithResponse call
func ParseResumeVmResponse(rsp *http.Response) (*ResumeVmResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ResumeVmResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Errors *[]interface{} `json:"errors,omitempty"`
			Help   *struct {
				DataForVirtualMachineExecTasks *struct {
					OrkaVmName *string `json:"orka_vm_name,omitempty"`
				} `json:"data_for_virtual_machine_exec_tasks,omitempty"`
				ResumeVirtualMachine    *string `json:"resume_virtual_machine,omitempty"`
				RevertVirtualMachine    *string `json:"revert_virtual_machine,omitempty"`
				SaveVirtualMachineState *string `json:"save_virtual_machine_state,omitempty"`
				StartVirtualMachine     *string `json:"start_virtual_machine,omitempty"`
				StopVirtualMachine      *string `json:"stop_virtual_machine,omitempty"`
				SuspendVirtualMachine   *string `json:"suspend_virtual_machine,omitempty"`
			} `json:"help,omitempty"`
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseRevertVmResponse parses an HTTP response from a RevertVmWithResponse call
func ParseRevertVmResponse(rsp *http.Response) (*RevertVmResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RevertVmResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Errors *[]interface{} `json:"errors,omitempty"`
			Help   *struct {
				DataForVirtualMachineExecTasks *struct {
					OrkaNodeName *string `json:"orka_node_name,omitempty"`
					OrkaVmName   *string `json:"orka_vm_name,omitempty"`
				} `json:"data_for_virtual_machine_exec_tasks,omitempty"`
				ResumeVirtualMachine    *string `json:"resume_virtual_machine,omitempty"`
				RevertVirtualMachine    *string `json:"revert_virtual_machine,omitempty"`
				SaveVirtualMachineState *string `json:"save_virtual_machine_state,omitempty"`
				StartVirtualMachine     *string `json:"start_virtual_machine,omitempty"`
				StopVirtualMachine      *string `json:"stop_virtual_machine,omitempty"`
				SuspendVirtualMachine   *string `json:"suspend_virtual_machine,omitempty"`
				VirtualMachineVnc       *string `json:"virtual_machine_vnc,omitempty"`
			} `json:"help,omitempty"`
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseStartVmResponse parses an HTTP response from a StartVmWithResponse call
func ParseStartVmResponse(rsp *http.Response) (*StartVmResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StartVmResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Errors *[]interface{} `json:"errors,omitempty"`
			Help   *struct {
				DataForVirtualMachineExecTasks *struct {
					OrkaVmName *string `json:"orka_vm_name,omitempty"`
				} `json:"data_for_virtual_machine_exec_tasks,omitempty"`
				ResumeVirtualMachine    *string `json:"resume_virtual_machine,omitempty"`
				RevertVirtualMachine    *string `json:"revert_virtual_machine,omitempty"`
				SaveVirtualMachineState *string `json:"save_virtual_machine_state,omitempty"`
				StartVirtualMachine     *string `json:"start_virtual_machine,omitempty"`
				StopVirtualMachine      *string `json:"stop_virtual_machine,omitempty"`
				SuspendVirtualMachine   *string `json:"suspend_virtual_machine,omitempty"`
			} `json:"help,omitempty"`
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseStopVmResponse parses an HTTP response from a StopVmWithResponse call
func ParseStopVmResponse(rsp *http.Response) (*StopVmResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StopVmResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Errors *[]interface{} `json:"errors,omitempty"`
			Help   *struct {
				DataForVirtualMachineExecTasks *struct {
					OrkaNodeName *string `json:"orka_node_name,omitempty"`
					OrkaVmName   *string `json:"orka_vm_name,omitempty"`
				} `json:"data_for_virtual_machine_exec_tasks,omitempty"`
				ResumeVirtualMachine    *string `json:"resume_virtual_machine,omitempty"`
				RevertVirtualMachine    *string `json:"revert_virtual_machine,omitempty"`
				SaveVirtualMachineState *string `json:"save_virtual_machine_state,omitempty"`
				StartVirtualMachine     *string `json:"start_virtual_machine,omitempty"`
				StopVirtualMachine      *string `json:"stop_virtual_machine,omitempty"`
				SuspendVirtualMachine   *string `json:"suspend_virtual_machine,omitempty"`
				VirtualMachineVnc       *string `json:"virtual_machine_vnc,omitempty"`
			} `json:"help,omitempty"`
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSuspendVmResponse parses an HTTP response from a SuspendVmWithResponse call
func ParseSuspendVmResponse(rsp *http.Response) (*SuspendVmResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SuspendVmResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Errors *[]interface{} `json:"errors,omitempty"`
			Help   *struct {
				DataForVirtualMachineExecTasks *struct {
					OrkaNodeName *string `json:"orka_node_name,omitempty"`
					OrkaVmName   *string `json:"orka_vm_name,omitempty"`
				} `json:"data_for_virtual_machine_exec_tasks,omitempty"`
				ResumeVirtualMachine    *string `json:"resume_virtual_machine,omitempty"`
				RevertVirtualMachine    *string `json:"revert_virtual_machine,omitempty"`
				SaveVirtualMachineState *string `json:"save_virtual_machine_state,omitempty"`
				StartVirtualMachine     *string `json:"start_virtual_machine,omitempty"`
				StopVirtualMachine      *string `json:"stop_virtual_machine,omitempty"`
				SuspendVirtualMachine   *string `json:"suspend_virtual_machine,omitempty"`
				VirtualMachineVnc       *string `json:"virtual_machine_vnc,omitempty"`
			} `json:"help,omitempty"`
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListYourVMsResponse parses an HTTP response from a ListYourVMsWithResponse call
func ParseListYourVMsResponse(rsp *http.Response) (*ListYourVMsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListYourVMsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Errors                  *[]interface{}          `json:"errors,omitempty"`
			Help                    *map[string]interface{} `json:"help,omitempty"`
			Message                 *string                 `json:"message,omitempty"`
			VirtualMachineResources *[]struct {
				BaseImage             *string  `json:"base_image,omitempty"`
				ConfigurationTemplate *string  `json:"configuration_template,omitempty"`
				Cpu                   *float32 `json:"cpu,omitempty"`
				GpuPassthrough        *bool    `json:"gpu_passthrough,omitempty"`
				Image                 *string  `json:"image,omitempty"`
				IoBoost               *bool    `json:"io_boost,omitempty"`
				Owner                 *string  `json:"owner,omitempty"`
				Status                *[]struct {
					RAM                   *string  `json:"RAM,omitempty"`
					BaseImage             *string  `json:"base_image,omitempty"`
					ConfigurationTemplate *string  `json:"configuration_template,omitempty"`
					Cpu                   *float32 `json:"cpu,omitempty"`
					CreationTimestamp     *string  `json:"creationTimestamp,omitempty"`
					Image                 *string  `json:"image,omitempty"`
					IoBoost               *bool    `json:"io_boost,omitempty"`
					NodeLocation          *string  `json:"node_location,omitempty"`
					NodeStatus            *string  `json:"node_status,omitempty"`
					Owner                 *string  `json:"owner,omitempty"`
					ReservedPorts         *[]struct {
						GuestPort *float32 `json:"guest_port,omitempty"`
						HostPort  *float32 `json:"host_port,omitempty"`
						Protocol  *string  `json:"protocol,omitempty"`
					} `json:"reserved_ports,omitempty"`
					ScreenSharingPort  *string  `json:"screen_sharing_port,omitempty"`
					SshPort            *string  `json:"ssh_port,omitempty"`
					UseSavedState      *bool    `json:"use_saved_state,omitempty"`
					Vcpu               *float32 `json:"vcpu,omitempty"`
					VirtualMachineId   *string  `json:"virtual_machine_id,omitempty"`
					VirtualMachineIp   *string  `json:"virtual_machine_ip,omitempty"`
					VirtualMachineName *string  `json:"virtual_machine_name,omitempty"`
					VmStatus           *string  `json:"vm_status,omitempty"`
					VncPort            *string  `json:"vnc_port,omitempty"`
				} `json:"status,omitempty"`
				UseSavedState      *bool    `json:"use_saved_state,omitempty"`
				Vcpu               *float32 `json:"vcpu,omitempty"`
				VirtualMachineName *string  `json:"virtual_machine_name,omitempty"`
				VmDeploymentStatus *string  `json:"vm_deployment_status,omitempty"`
			} `json:"virtual_machine_resources,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListDisksResponse parses an HTTP response from a ListDisksWithResponse call
func ParseListDisksResponse(rsp *http.Response) (*ListDisksResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListDisksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Drives *[]struct {
				Device *string `json:"device,omitempty"`
				Source *string `json:"source,omitempty"`
				Target *string `json:"target,omitempty"`
				Type   *string `json:"type,omitempty"`
			} `json:"drives,omitempty"`
			Errors  *[]interface{}          `json:"errors,omitempty"`
			Help    *map[string]interface{} `json:"help,omitempty"`
			Message *string                 `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListAllVMsAdminResponse parses an HTTP response from a ListAllVMsAdminWithResponse call
func ParseListAllVMsAdminResponse(rsp *http.Response) (*ListAllVMsAdminResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAllVMsAdminResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Errors                  *[]interface{}          `json:"errors,omitempty"`
			Help                    *map[string]interface{} `json:"help,omitempty"`
			Message                 *string                 `json:"message,omitempty"`
			VirtualMachineResources *[]struct {
				BaseImage             *string  `json:"base_image,omitempty"`
				ConfigurationTemplate *string  `json:"configuration_template,omitempty"`
				Cpu                   *float32 `json:"cpu,omitempty"`
				GpuPassthrough        *bool    `json:"gpu_passthrough,omitempty"`
				Image                 *string  `json:"image,omitempty"`
				IoBoost               *bool    `json:"io_boost,omitempty"`
				Owner                 *string  `json:"owner,omitempty"`
				Status                *[]struct {
					RAM                   *string  `json:"RAM,omitempty"`
					BaseImage             *string  `json:"base_image,omitempty"`
					ConfigurationTemplate *string  `json:"configuration_template,omitempty"`
					Cpu                   *float32 `json:"cpu,omitempty"`
					CreationTimestamp     *string  `json:"creationTimestamp,omitempty"`
					Image                 *string  `json:"image,omitempty"`
					IoBoost               *bool    `json:"io_boost,omitempty"`
					NodeLocation          *string  `json:"node_location,omitempty"`
					NodeStatus            *string  `json:"node_status,omitempty"`
					Owner                 *string  `json:"owner,omitempty"`
					ReservedPorts         *[]struct {
						GuestPort *float32 `json:"guest_port,omitempty"`
						HostPort  *float32 `json:"host_port,omitempty"`
						Protocol  *string  `json:"protocol,omitempty"`
					} `json:"reserved_ports,omitempty"`
					ScreenSharingPort  *string  `json:"screen_sharing_port,omitempty"`
					SshPort            *string  `json:"ssh_port,omitempty"`
					UseSavedState      *bool    `json:"use_saved_state,omitempty"`
					Vcpu               *float32 `json:"vcpu,omitempty"`
					VirtualMachineId   *string  `json:"virtual_machine_id,omitempty"`
					VirtualMachineIp   *string  `json:"virtual_machine_ip,omitempty"`
					VirtualMachineName *string  `json:"virtual_machine_name,omitempty"`
					VmStatus           *string  `json:"vm_status,omitempty"`
					VncPort            *string  `json:"vnc_port,omitempty"`
				} `json:"status,omitempty"`
				UseSavedState      *bool    `json:"use_saved_state,omitempty"`
				Vcpu               *float32 `json:"vcpu,omitempty"`
				VirtualMachineName *string  `json:"virtual_machine_name,omitempty"`
				VmDeploymentStatus *string  `json:"vm_deployment_status,omitempty"`
			} `json:"virtual_machine_resources,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListUserSVMsAdminResponse parses an HTTP response from a ListUserSVMsAdminWithResponse call
func ParseListUserSVMsAdminResponse(rsp *http.Response) (*ListUserSVMsAdminResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListUserSVMsAdminResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Errors                  *[]interface{}          `json:"errors,omitempty"`
			Help                    *map[string]interface{} `json:"help,omitempty"`
			Message                 *string                 `json:"message,omitempty"`
			VirtualMachineResources *[]struct {
				BaseImage             *string  `json:"base_image,omitempty"`
				ConfigurationTemplate *string  `json:"configuration_template,omitempty"`
				Cpu                   *float32 `json:"cpu,omitempty"`
				GpuPassthrough        *bool    `json:"gpu_passthrough,omitempty"`
				Image                 *string  `json:"image,omitempty"`
				IoBoost               *bool    `json:"io_boost,omitempty"`
				Owner                 *string  `json:"owner,omitempty"`
				Status                *[]struct {
					RAM                   *string  `json:"RAM,omitempty"`
					BaseImage             *string  `json:"base_image,omitempty"`
					ConfigurationTemplate *string  `json:"configuration_template,omitempty"`
					Cpu                   *float32 `json:"cpu,omitempty"`
					CreationTimestamp     *string  `json:"creationTimestamp,omitempty"`
					Image                 *string  `json:"image,omitempty"`
					IoBoost               *bool    `json:"io_boost,omitempty"`
					NodeLocation          *string  `json:"node_location,omitempty"`
					NodeStatus            *string  `json:"node_status,omitempty"`
					Owner                 *string  `json:"owner,omitempty"`
					ReservedPorts         *[]struct {
						GuestPort *float32 `json:"guest_port,omitempty"`
						HostPort  *float32 `json:"host_port,omitempty"`
						Protocol  *string  `json:"protocol,omitempty"`
					} `json:"reserved_ports,omitempty"`
					ScreenSharingPort  *string  `json:"screen_sharing_port,omitempty"`
					SshPort            *string  `json:"ssh_port,omitempty"`
					UseSavedState      *bool    `json:"use_saved_state,omitempty"`
					Vcpu               *float32 `json:"vcpu,omitempty"`
					VirtualMachineId   *string  `json:"virtual_machine_id,omitempty"`
					VirtualMachineIp   *string  `json:"virtual_machine_ip,omitempty"`
					VirtualMachineName *string  `json:"virtual_machine_name,omitempty"`
					VmStatus           *string  `json:"vm_status,omitempty"`
					VncPort            *string  `json:"vnc_port,omitempty"`
				} `json:"status,omitempty"`
				UseSavedState      *bool    `json:"use_saved_state,omitempty"`
				Vcpu               *float32 `json:"vcpu,omitempty"`
				VirtualMachineName *string  `json:"virtual_machine_name,omitempty"`
				VmDeploymentStatus *string  `json:"vm_deployment_status,omitempty"`
			} `json:"virtual_machine_resources,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseMigrateVmResponse parses an HTTP response from a MigrateVmWithResponse call
func ParseMigrateVmResponse(rsp *http.Response) (*MigrateVmResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MigrateVmResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Errors       *[]interface{}          `json:"errors,omitempty"`
			Help         *map[string]interface{} `json:"help,omitempty"`
			Message      *string                 `json:"message,omitempty"`
			PortWarnings *[]interface{}          `json:"port_warnings,omitempty"`
			VmId         *string                 `json:"vm_id,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePurgeUserSVMsAdminResponse parses an HTTP response from a PurgeUserSVMsAdminWithResponse call
func ParsePurgeUserSVMsAdminResponse(rsp *http.Response) (*PurgeUserSVMsAdminResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PurgeUserSVMsAdminResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Errors *[]interface{} `json:"errors,omitempty"`
			Help   *struct {
				CreateVirtualMachineConfiguration *string `json:"create_virtual_machine_configuration,omitempty"`
				DeployVirtualMachine              *string `json:"deploy_virtual_machine,omitempty"`
				ListOrkaNodes                     *string `json:"list_orka_nodes,omitempty"`
				RequiredRequestDataForCreate      *struct {
					OrkaBaseImg *string `json:"orka_base_img,omitempty"`
					OrkaImage   *string `json:"orka_image,omitempty"`
					OrkaVmName  *string `json:"orka_vm_name,omitempty"`
				} `json:"required_request_data_for_create,omitempty"`
				RequiredRequestDataForDeploy *struct {
					OrkaNodeName *string `json:"orka_node_name,omitempty"`
					OrkaVmName   *string `json:"orka_vm_name,omitempty"`
				} `json:"required_request_data_for_deploy,omitempty"`
			} `json:"help,omitempty"`
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUnScaleVmResponse parses an HTTP response from a UnScaleVmWithResponse call
func ParseUnScaleVmResponse(rsp *http.Response) (*UnScaleVmResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UnScaleVmResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Errors  *[]interface{}          `json:"errors,omitempty"`
			Help    *map[string]interface{} `json:"help,omitempty"`
			Message *string                 `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCheckUserSVmStatusAdminResponse parses an HTTP response from a CheckUserSVmStatusAdminWithResponse call
func ParseCheckUserSVmStatusAdminResponse(rsp *http.Response) (*CheckUserSVmStatusAdminResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CheckUserSVmStatusAdminResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Errors                  *[]interface{}          `json:"errors,omitempty"`
			Help                    *map[string]interface{} `json:"help,omitempty"`
			Message                 *string                 `json:"message,omitempty"`
			VirtualMachineResources *[]struct {
				BaseImage             *string  `json:"base_image,omitempty"`
				ConfigurationTemplate *string  `json:"configuration_template,omitempty"`
				Cpu                   *float32 `json:"cpu,omitempty"`
				Image                 *string  `json:"image,omitempty"`
				IoBoost               *bool    `json:"io_boost,omitempty"`
				Owner                 *string  `json:"owner,omitempty"`
				UseSavedState         *bool    `json:"use_saved_state,omitempty"`
				Vcpu                  *float32 `json:"vcpu,omitempty"`
				VirtualMachineName    *string  `json:"virtual_machine_name,omitempty"`
				VmDeploymentStatus    *string  `json:"vm_deployment_status,omitempty"`
			} `json:"virtual_machine_resources,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseRevokeTokenResponse parses an HTTP response from a RevokeTokenWithResponse call
func ParseRevokeTokenResponse(rsp *http.Response) (*RevokeTokenResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RevokeTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Errors        *[]interface{}          `json:"errors,omitempty"`
			Help          *map[string]interface{} `json:"help,omitempty"`
			Message       *string                 `json:"message,omitempty"`
			TokensRevoked *float32                `json:"tokensRevoked,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCheckTokenStatusResponse parses an HTTP response from a CheckTokenStatusWithResponse call
func ParseCheckTokenStatusResponse(rsp *http.Response) (*CheckTokenStatusResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CheckTokenStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Authenticated  *bool                   `json:"authenticated,omitempty"`
			Email          *string                 `json:"email,omitempty"`
			Errors         *[]interface{}          `json:"errors,omitempty"`
			Help           *map[string]interface{} `json:"help,omitempty"`
			IsTokenRevoked *bool                   `json:"is_token_revoked,omitempty"`
			Message        *string                 `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateTokenResponse parses an HTTP response from a CreateTokenWithResponse call
func ParseCreateTokenResponse(rsp *http.Response) (*CreateTokenResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Errors  *[]interface{}          `json:"errors,omitempty"`
			Help    *map[string]interface{} `json:"help,omitempty"`
			Message *string                 `json:"message,omitempty"`
			Token   *string                 `json:"token,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetUsersResponse parses an HTTP response from a GetUsersWithResponse call
func ParseGetUsersResponse(rsp *http.Response) (*GetUsersResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Errors    *[]interface{}          `json:"errors,omitempty"`
			Help      *map[string]interface{} `json:"help,omitempty"`
			Message   *string                 `json:"message,omitempty"`
			UserCount *float32                `json:"user_count,omitempty"`
			UserList  *[]string               `json:"user_list,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateUserResponse parses an HTTP response from a CreateUserWithResponse call
func ParseCreateUserResponse(rsp *http.Response) (*CreateUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			Email   *string                 `json:"email,omitempty"`
			Errors  *[]interface{}          `json:"errors,omitempty"`
			Group   *string                 `json:"group,omitempty"`
			Help    *map[string]interface{} `json:"help,omitempty"`
			Message *string                 `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseUpdateUserResponse parses an HTTP response from a UpdateUserWithResponse call
func ParseUpdateUserResponse(rsp *http.Response) (*UpdateUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Errors              *[]interface{}          `json:"errors,omitempty"`
			Help                *map[string]interface{} `json:"help,omitempty"`
			Message             *string                 `json:"message,omitempty"`
			RecordsUpdatedCount *float32                `json:"records_updated_count,omitempty"`
			UserEmail           *string                 `json:"user_email,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUngroupUsersResponse parses an HTTP response from a UngroupUsersWithResponse call
func ParseUngroupUsersResponse(rsp *http.Response) (*UngroupUsersResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UngroupUsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Errors  *[]interface{}          `json:"errors,omitempty"`
			Help    *map[string]interface{} `json:"help,omitempty"`
			Message *string                 `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGroupUsersResponse parses an HTTP response from a GroupUsersWithResponse call
func ParseGroupUsersResponse(rsp *http.Response) (*GroupUsersResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GroupUsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Errors  *[]interface{}          `json:"errors,omitempty"`
			Help    *map[string]interface{} `json:"help,omitempty"`
			Message *string                 `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseResetPasswordAdminResponse parses an HTTP response from a ResetPasswordAdminWithResponse call
func ParseResetPasswordAdminResponse(rsp *http.Response) (*ResetPasswordAdminResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ResetPasswordAdminResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Errors  *[]interface{}          `json:"errors,omitempty"`
			Help    *map[string]interface{} `json:"help,omitempty"`
			Message *string                 `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteUserResponse parses an HTTP response from a DeleteUserWithResponse call
func ParseDeleteUserResponse(rsp *http.Response) (*DeleteUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Errors      *[]interface{}          `json:"errors,omitempty"`
			Help        *map[string]interface{} `json:"help,omitempty"`
			Message     *string                 `json:"message,omitempty"`
			UserDeleted *bool                   `json:"user_deleted,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseValidateLicenseKeyResponse parses an HTTP response from a ValidateLicenseKeyWithResponse call
func ParseValidateLicenseKeyResponse(rsp *http.Response) (*ValidateLicenseKeyResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ValidateLicenseKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Errors  *[]interface{}          `json:"errors,omitempty"`
			Help    *map[string]interface{} `json:"help,omitempty"`
			Message *string                 `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]struct {
				Message *string `json:"message,omitempty"`
			} `json:"errors,omitempty"`
			Help    *map[string]interface{} `json:"help,omitempty"`
			Message *string                 `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseCheckPasswordRequirementsResponse parses an HTTP response from a CheckPasswordRequirementsWithResponse call
func ParseCheckPasswordRequirementsResponse(rsp *http.Response) (*CheckPasswordRequirementsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CheckPasswordRequirementsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Errors         *[]interface{}          `json:"errors,omitempty"`
			Help           *map[string]interface{} `json:"help,omitempty"`
			Message        *string                 `json:"message,omitempty"`
			PasswordLength *float32                `json:"password_length,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}
